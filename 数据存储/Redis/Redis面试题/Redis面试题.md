# Redis面试题

## Redis概述

### redis 作用

1. 缓存

2. 分布式锁
3. 记录帖子的点赞数、评论数和点击数 (hash)。
4. 排行榜

**什么样的场景下适合用缓存？有什么特点的数据适合做缓存**

缓存服务使用场景

- 在一些大流量读场景，可以通过Redis进行数据缓存，减少DB库的访问次数，提升访问速度。

- 在一些DB读写同步及时性要求高同时读流量又很大的场景，可以尝试配合场景在写入时，优先写入缓存，再落盘。查时，直接查缓存，而不查读库。 

### redis怎么提高访问速率

### 说说redis

（介绍了单线程，多路复用，主从模式，哨兵模式，集群模式，rdb，aof持久化流程）

### Redis为什么那么快，性能更高

主要是单线程和多路复用机制

还有一些原因，Redis 的大部分操作在内存上完成，再加上它采用了高效的数据结构，例如哈希表和跳表，这是它实现高性能的一个重要原因。

#### 单线程

Redis 是单线程，主要是指 **Redis 的网络 IO 和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程。**但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。

**为什么使用单线程？**

因为多线程编程模式面临的共享资源的并发访问控制问题。

如果没有精细的设计，比如说，只是简单地采用一个粗粒度互斥锁，就会出现不理想的结果：即使增加了线程，大部分线程也在等待获取访问共享资源的互斥锁，并行变串行，系统吞吐率并没有随着线程的增加而增加。

而且，采用多线程开发一般会引入同步原语来保护共享资源的并发访问，这也会降低系统代码的易调试性和可维护性

为了避免这些问题，Redis 直接采用了单线程模式。

#### 多路复用机制

Redis 采用了多路复用机制，使其在网络 IO 操作中能并发处理大量的客户端请求，实现高吞吐率。

**Io多路复用是啥？**

Linux 中的 IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select/epoll 机制。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听套接字和已连接套接字。内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。

Redis 网络框架调用 epoll 机制，让内核监听多个套接字。此时，Redis 线程不会阻塞在某一个特定的监听或已连接套接字上，也就是说，不会阻塞在某一个特定的客户端请求处理上。正因为此，Redis 可以同时和多个客户端连接并处理请求，从而提升并发性。

select/epoll 提供了基于事件的回调机制，即针对不同事件的发生，调用相应的处理函数。那么，回调机制是怎么工作的呢？

其实，select/epoll 一旦监测到 FD 上有请求到达时，就会触发相应的事件。这些事件会被放进一个事件队列，Redis 单线程对该事件队列不断进行处理。这样一来，Redis 无需一直轮询是否有请求实际发生，这就可以避免造成 CPU 资源浪费。同时，Redis 在对事件队列中的事件进行处理时，会调用相应的处理函数，这就实现了基于事件的回调。因为 Redis 一直在对事件队列进行处理，所以能及时响应客户端请求，提升 Redis 的响应性能。

### redis的原理和实现

是一个高性能的 key-value 数据库。

有丰富的数据类型

Redis运行在内存中但是可以持久化到磁盘

## Redis的存储类型及底层实现

### Redis Object的底层实现

Z-Set基于什么？介绍一下跳表？jdk中的跳表？

> 见本目录下面的《Redis基础数据结构》和《Redis对象》

### 跳表如何维护

## redis的数据过期删除策略

redisDb结构的expires字典保存了数据库中的所有键的过期时间，称之为过期字典。

![image-20201115142425699](Redis面试题/image-20201115142425699.png)

过期键的判断是先找字典中有没有这个键，如果有的话，再判断当前Unix的时间戳是否大于键的过期时间，如果是的话，则表示已经过期了。

### 删除策略

redis是配合使用惰性删除和定期删除来实现的

**惰性删除的实现**

redis通过expireIfNeeded函数来实现。所有读写数据库的redis命令在执行之前都会调用expireIfNeeded函数对键进行检查，如果键已经过期了，就删除，如果没过期，就继续执行该命令。

但是惰性删除策略有个问题，如果键一直没有被访问到，那么这个过期键就永远不会删除。所以还需要定期删除配合。

**定期删除**

过期键的定期删除策略由redis.c/activeExpireCycle函数实现，每当Redis的服务器周期性操作redis.c/serverCron函数执行时，activeExpireCycle函数就会被调用，**它在规定的时间内**，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键。

函数每次执行的时候，都从一定数量的数据库中取出一定数量的随机键进行检查，并删除其中的过期键。

全局变量current_db会记录当前activeExpireCycle函数检查的进度，下一次接着上次的进度进行处理。比如这次遍历到10号数据库就返回了，下次就从11开始查找并删除过期键。

## 持久化方式

### 说说什么是RDB和AOF？

RDB通过持久化方式保存数据库中的键值对来记录数据库状态的不同。它保存的快照版本。

AOF(Appent Only File)通过保存redis服务器所执行的写命令来记录数据库的状态。

对于命令`SET msg "hello"`，

**RDB生成内容是:**

注意rdb文件是二进制文件，解析出来是这样：

```
\0 003 m s g 005 h e l l o
```

没有过期时间的键值对由类型、键、值三部分组成。字符串都是以字符串长度为前缀，后面跟着字符串的内容。

所以这里\0 表示类型是REDIS_RDB_TYPE_STRING(这个常量的实际值为0)，之后003是键msg的长度，005是值hello的长度。

如果有过期时间的键值，那么包括以下部分：

- 一个一字节长的EXPIRETIME_MS特殊值
- 一个八字节的过期时间（ms）
- 然后就是类型、键、值了

**AOF生成的内容是：**

```
*3\r\n$3\r\nSET\r\n$3\r\nmsg\r\n$5\r\nhello\r\n
```

\r\n是换行符，我们忽略就变成了在`*3  $3  SET  $3  msg  $5  hello`

*3表示有三个参数

$3表示下一个长度参数为3

set是命令，msg是key，hello是值

### 为什么要有两种持久化方式

**RDB优点：**

RDB 是一个非常紧凑（compact）的文件，它保存了 Redis 在某个时间点上的数据集。 这种文件非常适合用于进行备份： 比如说，你可以在最近的 24 小时内，每小时备份一次 RDB 文件，并且在每个月的每一天，也备份一个 RDB 文件。 这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。

RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。

**RDB缺点：**

服务器故障的时候，可能会丢失数据。如果你设置每五分钟保存文件的话，如果发生故障，这五分钟的数据你就没了。

**AOF优点**

使用 AOF 持久化会让 Redis 变得非常耐久

AOF 文件是一个只进行追加操作的日志文件（append only log）， 因此对 AOF 文件的写入不需要进行 `seek` 

**AOF的缺点**

对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。

根据所使用的 `fsync` 策略，AOF 的速度可能会慢于 RDB 

### 如果AOF文件很大怎么办

AOF重做，还是特别大怎么办，分片复制

**AOF重写**

一个list如果分六次放一个数据，就会在AOF中生成6条命令。所以可以重写，只生成一条命令。

重写AOF和之前的AOF文件没有关系，它是根据现在的redis数据库进行写入的。redis会生成一个子进程去进行重写，这样父进程的操作就不会阻塞了。

但是如果增量的数据怎么办？

redis有设置一个AOF重写缓冲区，当服务器创建子进程后，这个缓冲区开始使用。

当redis执行完一个写命令后，会把该语句发送给AOF缓冲区和AOF重写缓冲区。AOF缓冲区是为了对现在的AOF文件进行写入的。

当子进程完成AOF重写后，父进程就会将AOF重写缓冲区的所有内容写入到新AOF文件中，这样新文件保存的数据就和数据库一致了。

然后通过改名，用重写后的文件覆盖原有的AOF文件，完成替换。

## redis启动时怎么加载数据

**Redis开始加载数据到内存中，如果启用了appendonly了，则Redis从appendfile加载数据，否则就从dbfile加载数据**。

### 从appendfile中加载数据：

loadAppendOnlyFile()函数

在开始加载之前暂时关闭appendonly，然后Redis创建一个假的Redis客户端。

然后读取appendonly.aof文件中的命令，在假的Redis客户端上下文中执行，同时服务器也不对该客户端做任何应答。

### 从dbfile中加载数据

rdbLoad()函数

如果Redis没有开启appendonly，就需要从数据库文件中加载数据到内存，基本步骤如下：

a. 处理SELECT命令，即选择数据库 
b. 读取key 
c. 读取value 
d. 检测key是否过期 
e. 添加新的对象到哈希表 
f. 设置过期时间（如果需要） 
g. 如果开启了VM，处理swap操作

## 如果使用redis怎么解决自增主键在分布式下高并发的问题

主要是通过incr来操作的：对存储在指定`key`的数值执行原子的加1操作。

## redis分布式锁

### redis实现分布式锁是怎么做的

早期版本是通过SETNX和SETEX来实现的，只有当键不存在的时候设值，设值成功后，再给键设置过期时间，以防系统出问题，锁一直没法释放。

但是这样两条命令不是原子性的，所以从2.6.12版本开始，redis为`SET`命令增加了一系列选项:

```shell
SET key value [EX seconds] [PX milliseconds] [NX|XX]SET key value [EX seconds] [PX milliseconds] [NX|XX]
```

- `EX` *seconds* – 设置键key的过期时间，单位时秒
- `PX` *milliseconds* – 设置键key的过期时间，单位时毫秒
- `NX` – 只有键key不存在的时候才会设置key的值
- `XX` – 只有键key存在的时候才会设置key的值

官方提供了一个简单的例子：

命令 `SET resource-name token NX EX max-lock-time` 是一种用 Redis 来实现锁机制的简单方法。

如果上述命令返回`OK`，那么客户端就可以获得锁（如果上述命令返回Nil，那么客户端可以在一段时间之后重新尝试），并且可以通过LUA脚本来释放锁。

客户端加锁之后，如果没有主动释放，会在过期时间之后自动释放。

- token不是一个固定的字符串，而是一个随机的唯一标识，目的是为了只有自己才可以释放自己的锁，避免被其他线程释放了。

- 并且释放锁要通过LUA脚本，而不是DEL命令。

上述要点会避免下述场景：a客户端获得的锁（键key）已经由于过期时间到了被redis服务器删除，但是这个时候a客户端还去执行[DEL](http://www.redis.cn/commands/del.html)命令。而b客户端已经在a设置的过期时间之后重新获取了这个同样key的锁，那么a执行[DEL](http://www.redis.cn/commands/del.html)就会释放了b客户端加好的锁。

解锁脚本的一个例子将类似于以下：

```python
if redis.call("get",KEYS[1]) == ARGV[1]
then
    return redis.call("del",KEYS[1])
else
    return 0
end
```

这个脚本执行方式如下：

EVAL …script… 1 resource-name token-value

### 加锁失败会怎么样

如果加锁失败可以设置循环等待，在timeout时间内仍未获取到锁，则获取失败。

### 分布式锁如何实现按序获取锁？

zk锁

### 分布式锁和普通的锁的区别

普通锁只能单系统

## redis和memcache的区别

redis和memecache的不同在于： 
1、存储方式： 
memecache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小 
redis有部份存在硬盘上，这样能保证数据的持久性，支持数据的持久化（笔者注：有快照和AOF日志两种持久化方式，在实际应用的时候，要特别注意配置文件快照参数，要不就很有可能服务器频繁满载做dump）。 
2、数据支持类型： 
redis在数据支持上要比memecache多的多。 
3、使用底层模型不同： 
新版本的redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。 
4、运行环境不同： 
redis目前官方只支持LINUX 上去行，从而省去了对于其它系统的支持，这样的话可以更好的把精力用于本系统 环境上的优化

## 位图

也叫位数组

其实就是二进制数组，可以看做byte数组。

底层是使用字符串对象来存储的，因为字符串对象使用的SDS数据结构是二进制安全的，正好可以直接用SDS保存位数组。

比如对于字符串"he"

h的ASCII码的二进制是01101000，SDS每个buf数组是一字节，也就是8bit。

e的二进制是01100101，he合在一起就是01101000 01100101。

在buf数组中，就是这么存储的

![image-20201116160520683](Redis面试题/image-20201116160520683.png)

所以只需要设置1、2、4的值为1，就能得到h。

```sql
>setbit s 1 1
0
>setbit s 2 1
0
>setbit s 4 1
0
>get s
"h"
```

如果你接着设置后面位数的1，就能得到“he”

## redis多大内存，怎么扩容

redis设置配置文件的**maxmemory**参数，可以控制其最大可用内存大小（字节）。



## Redis哨兵

## Redis zset实现延时队列

## redis线程模型

io多路复用

## 缓存雪崩，缓存穿透，缓存击穿

缓存击穿怎么解决？

## Redis和数据库的一致性

## 用hashmap去实现Redis，你会怎么实现

##  redis其他的数据结构一般可以用于啥功能？你用过啥？

51. zset为什么可以做排行榜，底层是什么？
52. 那你讲讲跳表？

## netty和redis底层实现？

## Redis单点故障怎么解决

## Redis TTL原理

## Redis内存淘汰策略

## redis主从同步策略

## redis挂了怎么办？集群都挂了怎么办？

## 热key问题

## redis集群

### redis集群怎么做的，主从复制流程

### 选主？

### redis集群的架构

### redis集群某个节点挂了数据会丢掉吗?不会，到从节点去

如果没有从节点呢？也不会

### Redis集群下路由的选择,如何更高效（应该是Nginx吧）

### redis我想现在不停服务加集群集器怎么做

## redis端口

6379