# 为什么要用b+树

## B+树

B+树是从二叉查找树演化而来的。

树中的节点并不存储数据本身，而是只是作为索引，真正的数据放在了叶子节点。

除此之外，把每个叶子节点串在一条链表上，链表中的数据是从小到大有序的。(双向链表，因为查询经常有倒序查找)

如果数据量比较大，索引对应的树，也会比较占内存，所以需要把索引放到磁盘中。

不管是内存中的数据，还是磁盘中的数据，操作系统都是按页（一页大小通常是 4KB，这个值可以通过 getconfig PAGE_SIZE 命令查看）来读取的，一次会读一页的数据。如果要读取的数据量超过一页的大小，就会触发多次 IO 操作。所以，我们在选择 m 大小的时候，要尽量让每个节点的大小等于一个页的大小。读取一个节点，只需要一次磁盘 IO 操作。

**索引的更新：**如果加入一个值，正好这棵树超过了m，那么就要进行分裂，这样就可能引起父节点也超过了m，父节点也需要进行分裂。

如果删除一个值，可能导致每个索引下面只有一个值，这样，效率就会很低。

所以可以设置一个阈值等于 m/2。如果某个节点的子节点个数小于 m/2，我们就将它跟相邻的兄弟节点合并。不过，合并之后节点的子节点个数有可能会超过 m。针对这种情况，我们可以借助插入数据时候的处理方法，再分裂节点。

总结一下B+树的特点：

- 每个节点中子节点的个数不能超过 m，也不能小于 m/2；

- 根节点的子节点个数可以不超过 m/2，这是一个例外；
- m 叉树只存储索引，并不真正存储数据，这个有点儿类似跳表；
- 通过链表将叶子节点串联在一起，这样可以方便按区间查找
- 一般情况，根节点会被存储在内存中，其他节点存储在磁盘中。

## 哈希表

哈希表的查询性能很好，时间复杂度是 O(1)。但是，哈希表不能支持按照区间快速查找数据。所以，哈希表不能满足需求。

## 有序数组

查询可以使用二分法，时间复杂度是O(log(N))，也支持范围查找。但是更新效率太低了，插入一个数据，要移动后面的所有数据。

## 平衡二叉查找树

如果不是平衡二叉树的话，树有可能为线性的。二叉查找树虽然可以通过中序遍历得到从小到大的数据，但是还是没法支持按照区间进行查找。

## 跳表

跳表支持快速地插入、查找、删除数据，对应的时间复杂度是 O(logn)。也支持范围查找，所以是满足要求的。其实，跳表和B+树是比较类似的。

## B树

而 B 树实际上是低级版的 B+ 树，或者说 B+ 树是 B 树的改进版。

B 树跟 B+ 树的不同点主要集中在这几个地方：

- B+ 树中的节点不存储数据，只是索引，而 B 树中的节点存储数据；
- B 树中的叶子节点并不需要链表来串联。

也就是说，B 树只是一个每个节点的子节点个数不能小于 m/2 的 m 叉树。

## 红黑树

红黑树不是完全的平衡树，但是最坏情况高度不会超过2log(n)，所以也是相对平衡的。但是其实也是二叉树，没法实现范围查找。