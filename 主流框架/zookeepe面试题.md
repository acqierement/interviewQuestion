# zookeepe面试题

## zookeeper的通信原理

## zk如何实现分布式队列的？

其实很简单，建一个/queue的节点，然后队列就放到这个节点下面，由于是顺序节点，所以就可以用后缀数字表示顺序，数字越小表示在队头位置。

## zk如何实现分布式锁的？

讲讲他的触发机制？

在zk中创建一个节点叫lock表示锁，当有锁请求来的时候，就在lock下面建立一个顺序临时节点，如/lock/lockA-000001，如果当前节点在第一个，表示获取到了锁。

这时如果还有一个请求，就又建一个顺序临时节点/lock/lockB-000002，并且watch前一个节点——也就是000001的节点。当1的节点释放后，会通知2，此时2发现自己成了第一个位置，就知道自己获得了锁。

## zk一般用来干什么的？

### 数据发布与订阅（配置中心）

在我们平常的应用系统开发中，经常会碰到这样的需求：系统中需要使用一些通用的配置信息，例如**机器列表信息**、**数据库配置信息**等。这些全局配置信息通常具备以下3个特性。

- 数据量通常比较**小。**
- 数据内容在运行时**动态变化**。
- 集群中各机器共享，**配置一致**。

对于这样的全局配置信息就可以发布到ZooKeeper上，让客户端（集群的机器）去订阅该消息。

ZooKeeper采用的是**推拉相结合**的方式。如下：

客户端向服务端**注册**自己需要关注的节点，一旦该节点的数据发生**变更**，那么服务端就会向相应的客户端发送Watcher事件**通知**，客户端接收到这个消息通知后，需要**主动**到服务端**获取**最新的数据（**推拉结合**）。

### **命名服务(Naming Service)**

命名服务也是分布式系统中比较常见的一类场景。在分布式系统中，通过使用命名服务，客户端应用能够根据指定**名字**来获取**资源或服务的地址，提供者等信息**。被命名的实体通常可以是**集群中的机器，提供的服务，远程对象等等**——这些我们都可以统称他们为**名字（Name）**。其中较为常见的就是一些分布式服务框架（如RPC、RMI）中的服务地址列表。通过在ZooKeepr里创建顺序节点，能够很容易创建一个**全局唯一的路径**，这个路径就可以作为一个**名字**。

ZooKeeper的命名服务即生成**全局唯一的ID**。

### 分布式协调/通知

ZooKeeper中特有**Watcher注册**与**异步通知机制**，能够很好的实现分布式环境下不同机器，甚至不同系统之间的**通知与协调**，从而实现**对数据变更的实时处理**。使用方法通常是不同的客户端都对ZK上同一个ZNode进行注册，监听ZNode的变化（包括ZNode本身内容及子节点的），如果ZNode发生了变化，那么所有订阅的客户端都能够接收到相应的Watcher通知，并做出相应的处理。

**ZK的分布式协调/通知，是一种通用的分布式系统机器间的通信方式**。

包括心跳检测和工作进度汇报

### Master选举

**Master选举**可以说是ZooKeeper**最典型的应用场景**了。比如HDFS中Active NameNode的选举、YARN中Active ResourceManager的选举和HBase中Active HMaster的选举等。

针对Master选举的需求，通常情况下，我们可以选择常见的**关系型数据库**中的**主键特性**来实现：希望成为Master的机器都向数据库中插入一条**相同主键ID**的记录，数据库会帮我们进行**主键冲突检查**，也就是说，**只有一台**机器能插入成功——那么，我们就认为向数据库中**成功插入**数据的客户端机器**成为Master**。

依靠关系型数据库的主键特性确实能够很好地保证在集群中选举出唯一的一个Master。但是，如果当前选举出的Master挂了，那么该如何处理？谁来告诉我Master挂了呢？显然，关系型数据库无法通知我们这个事件。但是，ZooKeeper可以做到！

利用ZooKeepr的强一致性，能够很好地保证在分布式高并发情况下节点的创建一定能够保证全局唯一性，即ZooKeeper将会保证客户端**无法创建一个已经存在的ZNode**。也就是说，如果同时有多个客户端请求创建**同一个**临时节点，那么最终一定**只有一个**客户端请求能够创建成功。利用这个特性，就能很容易地在分布式环境中进行Master选举了。

成功创建该节点的客户端所在的机器就成为了Master。同时，其他没有成功创建该节点的客户端，都会在该节点上**注册**一个子节点变更的**Watcher**，用于监控当前Master机器是否存活，一旦发现当前的Master挂了，那么其他客户端将会**重新进行Master选举**。

这样就实现了Master的**动态选举**。



具体例子

hadoop:使用Zookeeper做nameNodede高可用（只要是主备切换，从节点watch主节点，如果挂了就可以切换）

Hbase: 保证集群中只有一个master。

## Zab协议

全称：ZooKeeper Atomic Broadcast (zk的原子性广播）

Quorum网络通信

每个followerJ节点会和leader节点建立一个tcp连接。之后通信都用这些建立的连接来进行。这一部分没有使用NIO和Netty。

在Zookeeper中主要依赖Zab协议来实现数据一致性，基于该协议，zk实现了一种主备模型（即Leader和Follower模型）的系统架构来保证集群中各个副本之间数据的一致性。
 这里的主备系统架构模型，就是**指只有一台客户端（Leader）负责处理外部的写事务请求，然后Leader客户端将数据同步到其他Follower节点。**

Zookeeper 客户端会随机的链接到 zookeeper 集群中的一个节点，如果是读请求，就直接从当前节点中读取数据；如果是写请求，那么节点就会向 Leader 提交事务，Leader 接收到事务提交，会广播该事务，只要超过半数节点写入成功，该事务就会被提交。

Zab协议的核心：**定义了事务请求的处理方式**

1）所有的事务请求必须由一个全局唯一的服务器来协调处理，这样的服务器被叫做 **Leader服务器**。其他剩余的服务器则是 **Follower服务器**。

2）Leader服务器 负责将一个客户端事务请求，转换成一个 **事务Proposal**，并将该 Proposal 分发给集群中所有的 Follower 服务器，也就是向所有 Follower 节点发送数据广播请求（或数据复制）

3）分发之后Leader服务器需要等待所有Follower服务器的反馈（Ack请求），**在Zab协议中，只要超过半数的Follower服务器进行了正确的反馈**后（也就是收到半数以上的Follower的Ack请求），那么 Leader 就会再次向所有的 Follower服务器发送 Commit 消息，要求其将上一个 事务proposal 进行提交。

## 为什么用过半投票机制？

zookeeper中的过半机制保证了zookeeper集群的数据一致性。

只有这样才可以找到相对可靠的数据