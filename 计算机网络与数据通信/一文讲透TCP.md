# 一文讲透TCP

TCP（Transmission Control Protocol 传输控制协议），它是面向连接的协议，可以实现可靠的传输。它解决了很多问题，包括丢包，乱序，拥塞等问题都有相应的解决方案。

我们来看看TCP到底是如何解决这些问题的，一下是本文大纲：

## TCP头的格式

![tcp头格式](H:\Adata\gitHubWorkspace\interviewQuestion\计算机网络与数据通信\配置图片\tcp格式.png)

可以看到有源端口和目标端口，和UDP一样，这个是必不可少的。

序号是给包的编号，用来解决乱序问题

第三行的确认序号。你不知道发出去的包对方有没有收到，如果对方收到了会给你个确认序号，作为一个靠谱的协议，只有确认过的才放心，否则已经发出去但是一直没有确认的，就需要重发。

其余的首部长度，保留（Resv），窗口大小，校验和，紧急指针，选项都很好理解，就是字面意思。

这里还有一些标志位，我们在连接的时候会用到，SYN是发起一个连接，ACK是回复，RST是重新连接，FIN是结束连接。

这里有些东西我们后面还会细讲。

## 序列号和确认应答

### 确认应答

当发送端的数据到达接收主机的时候，接收端会返回一个已经收到的通知，叫做确认应答（ACK)。如果发送端发了1~1000的数据，接收端接收到了之后，会返回一个确认应答，告诉发送方下个数据是1001。如果发送方一直没有等到的话，就会认为这个数据丢失了，会重发。

### 序列号

但是没有收到应答可能是接收方收到了，但是返回的确认应答丢失了，发送方没有收到确认应答。对于发送方，就按照数据丢失了，进行重发，但是对于接收端一直收到重复的信息，简直就是灾难啊，所以需要引入序号，来分辨哪些数据已经接收了，哪些数据还没有接收。

### 重发超时如何确定

多长时间才能判断一个数据已经丢失了呢？在不同的网络和不同的时段，网络状况都会有变化，所以这个超时的时长也必须是动态的。

TCP在每次发包的时候，都会计算往返时间及其偏差。将这个往返时间和偏差值相加，超时重发的时间就是比这个总和要稍大一点的值。

之所以要考虑偏差值，是因为有些网络比较稳定，而有些网络可能波动很大。加上偏差值之后，就会比较合理，像下面这种样子。

![超时重传时间](H:\Adata\gitHubWorkspace\interviewQuestion\计算机网络与数据通信\配置图片\超时重传时间small.jpg)

如果一个数据多次超时了，那么下一次超时重发的间隔会是前一次的两倍，这是为了避免在网络情况特别差的情况，发生频繁重发的情况。

超时触发重传存在的问题是，超时周期可能相对较长。那是不是可以有更快的方式呢？

有一个可以快速重传的机制，当接收方收到一个序号大于下一个所期望的报文段时，就检测到了数据流中的一个间格，于是发送三个冗余的 ACK，客户端收到后，就在定时器过期之前，重传丢失的报文段。例如，接收方发现 6、8、9 都已经接收了，就是 7 没来，那肯定是丢了，于是发送三个 6 的 ACK，要求下一个是 7。客户端收到 3 个，就会发现 7 的确又丢了，不等超时，马上重发。

还有一种方式称为Selective Acknowledgment （SACK）。这种方式需要在 TCP 头里加一个 SACK 的东西，可以将缓存的地图发送给发送方。例如可以发送 ACK6、SACK8、SACK9，有了地图，发送方一下子就能看出来是 7 丢了。

## 连接管理

TCP一个连接的建立和断开，正常情况至少需要来回发送七个包才能完成。

### TCP以段为单位发送数据

TCP连接建立的同时，会确定发送数据包的单位，我们称其为“最大消息长度”（MSS：Maximum Segment Size）。最理想的情况是，最大消息长度正好是IP中不会被分片处理的最大数据长度。

MMS是在三次握手的时候，在两端主机之间被计算出来的。建立连接的时候，两方分别会在TCP首部写入MMS选项，表示自己的接口能够适应的MSS大小。然后会在两者之间选择一个较小的值投入使用。

第一次握手，A表明自己的MMS是4312，B的MSS是1460，所以B在第二次握手的时候发送MMS：“我们就用1460吧”，第三次握手的时候，A发的应答消息就说明白了，然后后面传送数据就使用MMS=1460了。

### 三次握手

三次握手我们也常称为“请求 -> 应答 -> 应答之应答”的三个回合，具体的情况可以看图，这里我们就不说这个过程了，都被人说烂了。我们来讨论一下细节，为什么是三次而不是两次？四次？

A给B发送连接请求，如果 B 是乐意建立连接的，则会发送应答包给 A。但是这个应答包可能会丢失，B不敢就这样确定已经建立了连接。

如果两次就建立连接的话，B只要收到连接请求就会建立连接，这样是不可靠的。比如会有这种情况出现，A和B建立了一个很短的连接，连了一下马上就断开了。但是上次连接过程中A可能发送了很多请求信息，毕竟网络不是很好嘛，需要重发几次，这些请求在这时候达到B，B就认为A又发起请求了，然后发送一个应答包，准备接数据了。但是等半天不对劲啊，A收到了应答包，但是A根本没有发送请求，所以A对于这个包觉得莫名其妙，根本不会理会。结果B在那里单相思了半天。

所以两次肯定是不行的。对于B的应答，A应该再发送一个应答之应答，来让B放心。这样双方都有一个一发一收的过程。

那为什么不需要第四次呢？应答之应答也可能会丢失的？如果这样下去就没完了，第四次也可能会丢失的，第五次也可能丢失。所以向前面说的，双方都有个一发一收的过程就可以认为比较靠谱了。

而且如果第三次丢失了，就是 A 发给 B 的应答丢了，当 A 后续发送的数据到达的时候，B 可以认为这个连接已经建立，或者 B 压根就挂了，A 发送的数据，会报错，说 B 不可达，A 就知道 B 出事情了。

**序号的确认**

三次握手除了双方建立连接外，主要还是为了沟通一件事情，就是TCP 包的序号的问题。规定本次连接序号起始从哪一个号码开始。为什么需要确认序号呢？每次都从1 2 3开始不可以吗？

每次序号都相同的问题在于无法区分是哪一次连接的数据。

如果A和B之前建立了很短的连接，这次A给B发送了 1 2，B收到了1 2，可是接着还收到了3，但是A没发3啊，这个3是上次连接发送的，B不知道就当做这次的数据了，于是发生了错误。

因而，每个连接都要有不同的序号。这个序号的起始序号是随着时间变化的，可以看成一个 32 位的计数
器，每 4ms 加一，如果计算一下，如果到重复，需要 4 个多小时，那个绕路的包早就死翘翘了，因为我
们都知道 IP 包头里面有个 TTL，也即生存时间。

好了，双方终于建立了信任，建立了连接。为了维护这个连接，双方都要维护一个状态机，在连接建立的过程中，双方的状态变化时序图就像这样。

![](H:\Adata\gitHubWorkspace\interviewQuestion\计算机网络与数据通信\配置图片\三次握手.png)

一开始，客户端和服务端都处于 CLOSED 状态。先是服务端主动监听某个端口，处于 LISTEN 状态。然后客户端主动发起连接 SYN，之后处于 SYN-SENT 状态。服务端收到发起的连接，返回 SYN，并且ACK 客户端的 SYN，之后处于 SYN-RCVD 状态。客户端收到服务端发送的 SYN 和 ACK 之后，发送ACK 的 ACK，之后处于 ESTABLISHED状态，因为它一发一收成功了。服务端收到 ACK 的 ACK 之后，处于 ESTABLISHED 状态，因为它也一发一收了。

### TCP四次挥手

四次挥手直接看图吧，没什么好说的。TCP 协议还专门设计了几个状态。我们随便来看看断开连接的时候的状态时序图。

![四次挥手](H:\Adata\gitHubWorkspace\interviewQuestion\计算机网络与数据通信\配置图片\四次挥手.png)

断开的时候，我们可以看到，当 A 说“不玩了”，就进入 FIN_WAIT_1 的状态，B 收到“A 不玩”的消息后，发送知道了，就进入 CLOSE_WAIT 的状态。

A 收到“B 说知道了”，就进入 FIN_WAIT_2 的状态，如果这个时候 B 直接跑路，则 A 将永远在这个状态。TCP 协议里面并没有对这个状态的处理，但是 Linux 有，可以调整 tcp_fin_timeout 这个参数，设置一个超时时间。

如果 B 没有跑路，发送了“B 也不玩了”的请求到达 A 时，A 发送“知道 B 也不玩了”的 ACK 后，从FIN_WAIT_2 状态结束，按说 A 可以跑路了，但是最后的这个 ACK 万一 B 收不到呢？则 B 会重新发一个“B 不玩了”，这个时候 A 已经跑路了的话，B 就再也收不到 ACK 了，因而 TCP 协议要求 A 最后等待一段时间 TIME_WAIT，这个时间要足够长，到如果 B 没收到 ACK 的话，“B 说不玩了”会重发的，A 会重新发一个 ACK 并且足够时间到达 B。

A 直接跑路还有一个问题是，A 的端口就直接空出来了，但是 B 不知道，B 原来发过的很多包很可能还在路上，如果 A 的端口被一个新的应用占用了，这个新的应用会收到上个连接中 B 发过来的包，虽然序列号是重新生成的，但是这里要上一个双保险，防止产生混乱，因而也需要等足够长的时间，等到原来B 发送的所有的包都死翘翘，再空出端口来。

等待的时间设为 2MSL，MSL是Maximum Segment Lifetime，报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个TTL 域，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。协议规定 MSL 为 2 分钟，实际应用中常用的是 30秒，1 分钟和 2 分钟等。

还有一个异常情况就是，B 超过了 2MSL 的时间，依然没有收到它发的 FIN 的 ACK，怎么办呢？按照TCP 的原理，B 然还会重发 FIN，这个时候 A 再收到这个包之后，A 就表示，我已经在这里等了这么长时间了，已经仁至义尽了，之后的我就都不认了，于是就直接发送 RST，B 就知道 A 早就跑了。

## 窗口机制

### 窗口控制与重发机制

TCP以1个段为单位，每发一个段进行一次确认的话，只有前面那个段确认收到了，下一个段才可以发送，其余时间都在等着，这样子效率很低。

所以TCP引入了窗口这个概念，以更大的单位来进行发送。我们来看一下发送方和接收方的窗口是怎么样的。

**发送方**

![](H:\Adata\gitHubWorkspace\interviewQuestion\计算机网络与数据通信\配置图片\滑动窗口发送端.png)

**接收方**

![](H:\Adata\gitHubWorkspace\interviewQuestion\计算机网络与数据通信\配置图片\滑动窗口接收端.png)

有了窗口之后，TCP发送数据就是这个样子了

![](H:\Adata\gitHubWorkspace\interviewQuestion\计算机网络与数据通信\配置图片\窗口发送数据.jpg)

我们来看最前面的两个图，在发送端来看，1、2、3 已经发送并确认；4、5、6、7、8、9 都是发送了还没确认；10、11、12 是还没发出的；13、14、15 是接收方没有空间，不准备发的。

在接收端来看，1、2、3、4、5 是已经完成 ACK，但是没读取的；6、7 是等待接收的；8、9 是已经接收（注意这里8、9是实线），但是没有 ACK 的。

发送端和接收端当前的状态如下：

- 1、2、3 没有问题，双方达成了一致。
- 4、5 接收方说 ACK 了，但是发送方还没收到，有可能丢了，有可能在路上。
- 6、7、8、9 肯定都发了，但是 8、9 已经到了，但是 6、7 没到，出现了乱序，缓存着但是没办法
  ACK。

发送端没有收到4、5的确认，对应的就是第三幅图B到A的消息丢失了，如果4丢失了，5收到了。那么发送方接到5的确认，就可以确认接收方接收到了5，那么可以推测4接收方肯定也收到了。所以即使有少量的确认应答丢失也不会进行数据重发，可以通过下一个应答进行确认。

但是如果收到了4的确认，一直没有5，也没有5之后的确认，这是就用上了我们前面说的超时重发，使用自适应算法计算出了一个合适的超时时间，超过这个值就进行重发。但是这个时间都是会偏长的，如果每次都等超时，那会耗费很多时间。怎么办呢？

前面说的都是发送端，发送端发了一个数据之后，就只能一直等回信了，苦苦等了很长时间没等到，他才会再发送数据。发送端不知道数据到达接收端了没有，但是接收端就很清楚啊，所以接收端可以帮帮忙。

TCP有一个可以快速重传的机制，当接收方收到一个序号大于下一个所期望的报文段时，比如收到了6 8 9，发现数据流中有一个间格，7没有收到，于是发送三个冗余的 ACK，发送3个6的ACK，要求下一个数据是7，客户端收到后，就在定时器过期之前，重传数据7。

### 流量控制

如果接收端很忙，没法接收新的数据，而这时发送端还一直发，那么这些数据达到接收端都会被丢弃，就会导致发送端一直重发，所以，TCP提供了一种机制，可以让接收端向发送端通知自己可以接收数据的大小，其实就是我们前面说的窗口大小。

如果窗口大小不变，那么发送端收到了一个确认后，整个窗口往右平移一格，右边又有了可以发送的数据。但是如果窗口变小，假设减少了一个，那么接收端的窗口只有左边的会右移一个，右边的边界保持不动，这样子待发送的数据就会减少了。

极端情况下，接收端一直不处理数据，那么接收端最后等待接收的长度会变成0，就是自己的缓冲区已经满了，没法再接收了，这时候发送端也会通知接收端把窗口设置为0。这时候发送端不会发送数据，但是发送端什么都不干，就静静地等接收端发来更新窗口的消息也不太合适，如果这个消息中间丢失了怎么办？所以发送端会发送一个窗口探测的数据段，以此来获取最新的窗口大小信息。

### 拥塞控制

拥塞控制也是通过窗口的大小来控制的，前面的滑动窗口是怕发送方把接收方缓存塞满，而拥塞窗口是怕把网络塞满。这里的拥塞窗口是独立的，和前面提到的没有关系。

一开始，TCP不知道网络情况怎么样，担心如果突然发送一个较大量的数据，极有可能导致网络的瘫痪。所以TCP采用慢启动的方式对发送数据量进行控制。

在慢启动的时候，将拥塞窗口大小设置为1（1MSS)，当收到一次确认应答后，就将拥塞窗口的值加1，发送数据报的时候，要把拥塞窗口和前面提到的滑动窗口大小进行比较，选择较小的数值作为发送数据参考大小。

这样，拥塞窗口会以1、2、4、8这样的指数函数增长，指数级到后面增长速度是很快的，所以有一个慢启动阀值的概念，超过这个阀值，就以1/拥塞窗口的大小增加，一开始这个阀值是65535个字节。这时候假设当前窗口是8，那么要收到8个确认，窗口的值才会加一，所以就由指数级变成了线性级的增加。

但是虽然变成了线性，但是也还在增加啊，迟早会把网络挤爆的，那么会出现拥塞的情况，一种表现就是超时重发，那么此时需要降低速度，会把阀值设置成拥塞窗口的一半，把拥塞窗口设置为1。

原来窗口大小为最高峰，现在一下子就变成1了，这方式太激进了，会造成网络卡顿。

所以有另一种方法，前面我们提到了快速重传，就是会发送三个确认包，于是接收端就不必等待超时重传了，可以直接发送需要的数据包。TCP认为快速重传的情况不严重，阀值还是设置成拥塞窗口的一半，拥塞窗口不是变成1了，而是当前的阀值+3个数据段的大小，其实就是拥塞窗口变成原来的一半还大一点。此时拥塞窗口大小比阀值大一点，所以会以线性进行增长。

![](H:\Adata\gitHubWorkspace\interviewQuestion\计算机网络与数据通信\配置图片\tcp的窗口变化.jpg)

这样，TCP通信开始后，网络吞吐量会逐渐上升，但是随着网络拥堵的发生，吞吐量也会急速下降。于是会再次进入吞吐量慢慢上升的过程。因此所谓的TCP的吞吐量的特点就好像是在逐步占领网络带宽的感觉。

后来有了**TCP BBR** 拥塞算法。它企图找到一个平衡点，就是通过不断的加快发送速度，将管道填满，但是不要填满中间设备的缓存，因为这样时延会增加，在这个平衡点可以很好的达到高带宽和低时延的平衡。有兴趣可以自己了解一下。

## 提高网络利用率的规范

### Nagle算法

该算法是指发送端如果还有一些很少的数据需要发送的话，就进行延迟发送。

如果下面两个条件都不满足的话，就等待一段时间后在进行数据发送。

- 已发送的数据都已经收到确认应答时
- 可以发送最大端长度（MSS）的数据时

翻译一下，第一点就是既然发出去的数据对方都收到了，我这么点数据也发了得了。第二点，这个算法是对数据很少的情况，1MSS已经不算小数据了。

这个算法虽然可以提高网络利用率，但是可能会发生某种程度的延迟。所以在窗口系统（X Window System)和机械控制等领域中使用TCP时，往往会关闭对该算法的使用。

### 延迟确认应答

接收端如果每次都立刻回复确认应答的话，那么返回的窗口大小可能会很小，因为刚接收完数据，缓冲区肯定会减小。所以引入了一个方法，不马上应答，延迟一段时间再应答，这是说不定已经处理完了某些数据，缓存区又变大了一点，就不需要减少窗口了。有两种情况：

- 在没有收到2乘以最大长度的数据为止不做确认应答（根据操作系统不同，处理也不一样，有些只要收到两个包，即使数据长度没有到达要求也立即返回确认应答）
- 最大延迟0.5秒发送确认应答（有些操作系统设置为0.2秒左右）

解释一下就是只有收到足够多的数据了才应答，或者实在耽误太久了，才确认应答。

### 捎带应答

有些应用层协议，发送消息到对端后，对端处理后会返回一个回执。例如，电子邮件协议的SMTP和POP、文件传输协议FTP中的连接控制部分。HTTP1.1版本后的也是有回执的。

在此类通信中，TCP可以把确认应答和回执数据一起通过一个包发送。这种方式叫做捎带应答。

但是如果接收数据后立刻返回确认应答，就无法实现捎带应答。也就是说，如果没有启用前面提到的延迟确认应答，就无法实现捎带应答。

