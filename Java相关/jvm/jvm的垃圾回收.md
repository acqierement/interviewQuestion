# jvm的垃圾回收

[扒一扒JVM的垃圾回收机制，下次面试你准备好了吗](https://www.cnblogs.com/1024Community/p/honery.html)

## 判断对象是否存活

### 引用计数法

对象中添加一个引用计数器，每当有地方引用它的时候，计数器就加1，引用失效的时候，计数器就减1，如果计数器是0，则代表没有人引用它。

但是**缺点就是无法解决循环引用的问题**。如果A和B互相引用，这样两个对象的引用计数都是1，但是除此之外没有地方引用它们，这样它们就永远不会被回收。

### 可达性分析算法

从一系列GC Root出发，如果无法到达的对象，就当它已经死亡了。

这里要介绍一下什么可以作为gc root：

#### GC root

​    **a.** java虚拟机栈(栈帧中的本地变量表)中的引用的对象。 

​    **b**.方法区中的类静态属性引用的对象。 

​    **c**.方法区中的常量引用的对象。 

​    **d**.本地方法栈中JNI本地方法的引用对象

可达性算法可以解决循环问题，但是在多线程情况下可能出现问题。

一个线程把一个对象标记为不可达，但是另一个线程重新引用了，结果这个对象被回收了，结果之后要用到这个对象的时候，可能会造成系统崩溃。

而如果一个对象已经是可达到的，但是后面又把它设置成null，这样这个对象就变成垃圾了，可是GC的时候却没把它当成垃圾收集。

所以在GC过程中会出现一些停顿，Sun称为stop the world。我理解就是所有的程序都停下来，让GC完成任务。把所有程序停下来感觉挺夸张的，但是现在已经优化得很好了，通常就一瞬间的事，表现就像停顿了一下。

当然stop the world 的过程中也有很多细节，程序也不是可以在任意时刻就停止的，不然可能造成其他程序的错误。这里有安全点和安全区域的概念，就是程序跑到这个安全点的位置才可以放心的停止。

而有些线程可能休眠了，无法跑到安全点，但是也有个安全区域，比如程序休眠了，那么此时程序就会标记自己在安全区域了，GC的时候就不用担心这些在安全区域的线程了。而这些安全区域的线程如果要离开安全区域的时候，会判断一下系统是否在GC，只有不在GC的时候才会离开安全区域。

无论是引用计数，还是可达性分析，都需要判断对象是否被引用。这里有一个引用的概念：强引用、软引用、弱引用、虚引用。这四种引用强度依次减弱，强引用是不会被回收的，其余都有可能被回收。

## 垃圾收集算法

### 标记-清除算法

把死亡的对象空间标记为空闲内存，并记录在一个空闲列表中（free list），当需要创建内存的时候，就去空闲列表里面找，并划分给新建的对象。缺点就是会有空间碎片

### 复制算法

可以把内存分成两份，一个空间满了之后，就根据gc root扫描，把存活的对象移到另外的空间，然后再把原来的空间清空，这样就不会有空间碎片。缺点也很明显，内存变成了原来的一半，浪费空间

### 标记-整理算法

在标记-清除的基础上，会整理内存，不会有空间碎片。缺点就是要移动对象，因此成本更高

### 分代收集算法

当前的主流方法，对不同的年代，使用不同的算法。我们重点来看一下。

按照通常的 GC 年代方式划分，Java 堆内分为：

1. 新生代

新生代是大部分对象创建和销毁的区域，在通常的 Java 应用中，绝大部分对象生命周期都是很短暂的。其内部又分为 Eden 区域，作为对象初始分配的区域；两个 Survivor，有时候也叫 from、to 区域，被用来放置从 Minor GC 中保留下来的对象。

JVM 会随意选取一个 Survivor 区域作为“to”，然后会在 GC 过程中进行区域间拷贝，也就是将 Eden 中存活下来的对象和 from 区域的对象，拷贝到这个“to”区域。这种设计主要是为了防止内存的碎片化，并进一步清理无用对象。

#### TLAB

Hotspot JVM 还有一个概念叫做 Thread Local Allocation Buffer（TLAB），这是 JVM 为每个线程分配的一个私有缓存区域。

因为我们使用new指令的时候，会在Eden区域划出一块作为存储对象的内存，由于堆空间是线程共享的，所以可能出现多个线程操作同一地址，为了避免这种情况，可能需要使用加锁等机制，但是会影响分配速度。

所以每个线程可以向虚拟机申请一段连续的内存，比如2048字节，作为线程私有的TLAB。线程维护两个指针，一个指向TLAB的空闲位置，另一个指向TLAB的结尾。

当对于new指令，可以使用指针加法来实现，即把指向空闲位置的指针，加上所请求的字节数。如果TLAB空间不够，可以重新申请新的TLAB

![TLAB示意图](.\image\TLAB.png)

2. 老年代

放置长生命周期的对象，通常都是从 Survivor 区域拷贝过来的对象。当然，也有特殊情况，我们知道普通的对象会被分配在 TLAB 上；如果对象较大，JVM 会试图直接分配在 Eden 其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM 就会直接分配到老年代。

3. 永久代

这部分就是早期 Hotspot JVM 的方法区实现方式了，储存 Java 类元数据、常量池、Intern 字符串缓存，在 JDK 8 之后就不存在永久代这块儿了。

来看一下新生代GC的过程

#### 新生代GC的过程

第一，Java 应用不断创建对象，通常都是分配在 Eden 区域，当其空间占用达到一定阈值时，触发 minor GC。仍然被引用的对象存活下来，被复制到 JVM 选择的 Survivor 区域，而没有被引用的对象则被回收。

第二， 经过一次 Minor GC，Eden 就会空闲下来，直到再次达到 Minor GC 触发条件，这时候，另外一个 Survivor 区域则会成为 to 区域，Eden 区域的存活对象和 From 区域对象，都会被复制到 to 区域，并且存活的年龄计数会被加 1。

第三， 类似第二步的过程会发生很多次，直到有对象年龄计数达到阈值，这时候就会发生所谓的晋升（Promotion）过程，超过阈值的对象会被晋升到老年代。这个阈值是可以通过参数指定：

-XX:MaxTenuringThreshold=&lt;N>

后面就是老年代 GC，具体取决于选择的 GC 选项，对应不同的算法。标记 - 整理算法中，老年代中的无用对象被清除后， GC 会将对象进行整理，以防止内存碎片化。

通常我们把老年代 GC 叫作 Major GC，将对整个堆进行的清理叫作 Full GC，但是这个也没有那么绝对，因为不同的老年代 GC 算法其实表现差异很大，例如 CMS，“concurrent”就体现在清理工作是与工作线程一起并发运行的。



## 垃圾收集器

谈谈最主流的 Oracle JDK的收集器。

### Serial GC

Serial GC，它是最古老的垃圾收集器，“Serial”体现在其收集工作是单线程的，并且在进行垃圾收集过程中，会进入臭名昭著的“Stop-The-World”状态。当然，其单线程设计也意味着精简的 GC 实现，无需维护复杂的数据结构，初始化也简单，所以一直是 Client 模式下 JVM 的默认选项。

从年代的角度，通常将其老年代实现单独称作 Serial Old，它采用了标记 - 整理（Mark-Compact）算法，区别于新生代的复制算法。

Serial GC 的对应 JVM 参数是：

-XX:+UseSerialGC

### ParNew GC

ParNew GC，很明显是个新生代 GC 实现，它实际是 Serial GC 的多线程版本，最常见的应用场景是配合老年代的 CMS GC 工作，下面是对应参数

-XX:+UseConcMarkSweepGC -XX:+UseParNewGC

### CMS

CMS（Concurrent Mark Sweep） GC，基于标记 - 清除（Mark-Sweep）算法，设计目标是尽量减少停顿时间，这一点对于 Web 等反应时间敏感的应用非常重要，一直到今天，仍然有很多系统使用 CMS GC。但是，CMS 采用的标记 - 清除算法，存在着内存碎片化问题，所以难以避免在长时间运行等情况下发生 full GC，导致恶劣的停顿。另外，既然强调了并发（Concurrent），CMS 会占用更多 CPU 资源，并和用户线程争抢。

### Parrallel GC

Parrallel GC，在早期 JDK 8 等版本中，它是 server 模式 JVM 的默认 GC 选择，也被称作是吞吐量优先的 GC。吞吐量就是cup运行用户代码的时间，吞吐量越大，表示运行用户代码的时间比例越多，gc占用的时间较少。它的算法和 Serial GC 比较相似，尽管实现要复杂的多，其特点是新生代和老年代 GC 都是并行进行的，在常见的服务器环境中更加高效。

开启选项是：

-XX:+UseParallelGC

另外，Parallel GC 引入了开发者友好的配置项，我们可以直接设置暂停时间或吞吐量等目标，JVM 会自动进行适应性调整，例如下面参数：

-XX:MaxGCPauseMillis=value-XX:GCTimeRatio=N // GC 时间和用户时间比例 = 1 / (N+1)

### G1 GC

G1 GC 这是一种兼顾吞吐量和停顿时间的 GC 实现，是 Oracle JDK 9 以后的默认 GC 选项。G1 可以直观的设定停顿时间的目标，相比于 CMS GC，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多。

G1 GC 仍然存在着年代的概念，但是其内存结构并不是简单的条带式划分，而是类似棋盘的一个个 region。Region 之间是复制算法，但整体上实际可看作是标记 - 整理（Mark-Compact）算法，可以有效地避免内存碎片，尤其是当 Java 堆非常大的时候，G1 的优势更加明显。

G1 吞吐量和停顿表现都非常不错，并且仍然在不断地完善，与此同时 CMS 已经在 JDK 9 中被标记为废弃（deprecated），所以 G1 GC 值得你深入掌握。

![垃圾收集器](.\image\垃圾收集器.png)



### 总结

serial是串行，其余都是并发的

Serial收集器：**串行运行**；作用于新生代；复制算法；响应速度优先；适用于单CPU环境下的client模式。

Serial Old收集器：**串行运行**；作用于老年代；标记-整理算法；响应速度优先；单CPU环境下的Client模式。

ParNew收集器：**多线程版的Serial**，用于新生代；复制算法；响应速度优先；多CPU环境Server模式下与CMS配合使用。

Parallel Scavenge收集器：**Parallel 被称作是吞吐量优先的 GC**；作用于新生代；复制算法；吞吐量优先；适用于后台运算而不需要太多交互的场景。

Parallel Old收集器：作用于老年代；标记-整理算法；吞吐量优先；适用于后台运算而不需要太多交互的场景。

CMS收集器：**设计目标是尽量减少停顿时间**；作用于老年代；标记-清除算法；响应速度优先；适用于互联网或B/S业务。 **CMS 已经在 JDK 9 中被标记为废弃**

G1收集器：**吞吐量和停顿表现都非常不错，并且仍然在不断地完善**；可作用于新生代或老年代；标记-整理算法+复制算法；响应速度优先；面向服务端应用。 



