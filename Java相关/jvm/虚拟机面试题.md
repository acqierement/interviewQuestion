# 虚拟机面试题

##  Java虚拟机的内存布局

## Minor GC 触发条件

## 垃圾回收器

 { serial  、 parallel 、 CMS 、 G1  }

CMS 、G1 重点 ， 介绍工作流程和优缺点

什么情况下会Stop The World？各个垃圾回收器STW的时机不完全相同，需分别讨论。

什么情况下用G1？

实时性要求高

G1和CMS有什么区别？

GC算法不同，G1为标记-整理、CMS为标记-清除，以及内存结构不同

## Eden和Survivor为什么是8：1，为什么使用标记复制和标记整理算法

## java垃圾回收，如何判断一个对象需要回收

## 对象可达性分析



## 判断对象死亡的方法 

## 你说到gcroot，哪些对象可以作为gcroot

## gc算法（深入一些： 各个算法的优点和适用场景）

## 如果对象大部分都是存活的，少部分需要清除，用什么算法

## 说说对象创建到消亡的过程

## 详细说说类加载的过程，静态代码块执行在哪个阶段

##  OOM情况如何排查

OOM介绍

## 内存泄漏

## 引用类型

{  强引用、 软引用、 弱引用 、 虚引用  }

## 类加载过程 ：

 { 加载 ， 连接 ， 初始化 }

有哪些类加载器 ， 能否自定义 Java.Object.String 的类加载器 ？

## 双亲委派机制 介绍 & 作用

spring中使用不同的类加载器，可以实现不同应用程序的文件，多个不同的版本。

JDBC违反了双亲委派模型，JDK中定义得接口但是所有厂商用的启动器不一样，所以只能用厂商加载器都不一样，导致违法了双亲委派模型

## 新生代用什么垃圾回收算法，为什么是1比1

## 如果是你，你怎么设计一款垃圾回收器，怎么减少fullGC时间

## 线程之间共享哪些内容？

不共享JVM调用栈、本地调用栈和程序计数器
如何访问这些共享的内容？
先访问CPU缓存，再访问Java内存，会有缓存一致性问题，可以使用volatile关键字
volatile和synchronized的区别？
一个保证缓存一致性，一个解决执行控制问题

## JVM调优参数

## Full GC，Minor GC

## 对象的栈上分配（JIT编译器）

## 类加载机制，不是类加载几个过程

## 如果多个类加载器加载同一个类，会出现什么情况

## tomcat的加载过程

## jstat的参数，比如看一个线程的回收情况，怎么看、其他的命令呢

## 动手去编译JDK源码

## JVM的类加载流程，到解析到字节码

## 如何去验证版本的冲突的，比如jdk1.6到jdk1.7

## 初始化去怎么做的

## 实际运用中，ClassLoader都有了解什么

## 如何实现一个动态加载、实现哪些方法

> 实现ClassLoader这个类

> 首先加载这个字节码的字符流，然后有个loader方法吧，记不太清楚了

## 如何获取当前的ClassLoader

getClassLoader方法

## 那可以保持建立多个ClassLoader吗？

> 给他扯到了不同ClassLoader加载一个clas出来的类不一样

## 为什么加载器加载出来的类不一样

> 不同加载器加载出来的类不一样，因为加载器不同啊
>
> 面试官补充：因为每个加载器都有自己的隔离机制

## jvm的锁优化有什么

说了synchronized

那还有其他编译器的锁优化吗，比如锁粗化？

锁消除、、、、、

## ClassLoader的分类

## 发现频繁Full GC怎么去排查和调整

- 用一个指令去参考Full GC的次数，新生代老年代的比例，调整各比例
- 产生Full GC的原因可能是：新生代到老年代的对象，老年代的空间不足，才产生Full GC

## 什么参数能够调整新生代的比例？



- -XX:SurvivorRatio：Eden和Survivor的比值，默认8:1
- -XX:NewRatio：老年代和年轻代内存大小的比例

## 程序发生内存泄漏，你会怎么去查这个问题？

产生内存泄漏的原因，可能是哪个引用没有用了，但是没有被回收

1. 那你如何查出这个代码
   - 没有实战过，不好意思
2. 换个思考吧，如果你的CPU突然变高，到100%，没有实战过，有什么思路吗？
   - 100%，肯定是代码块死循环了，我会用最笨的办法去找循环的代码，然后判断

## CMS回收几个阶段是只有自己的线程吗？还是多个线程并行

正确应该是

1. 初始标记 自己线程
2. 并发标记：并发标记线程+用户线程
3. 重新标记：重新标记线程
4. 并发清理：并发清理线程+用户线程
5. 并发重置：重置线程+用户线程

缺点：在并发清理过程中用户线程可能会产生大对象发生full gc，导致csm回收失败

## 编译时多态和运行时多态

## 类的一个创建过程

##  空间分配担保失败

## 讲讲一个对象在内存中的变化过程,什么时候从堆到其他区域

（我说创建对象实例在堆内存，做操作在栈里面，不懂~~~~~）

## java程序CPU非常高，你会怎么去排查，如何诊断代码问题？如何优化？

## java程序怎么查看gc

## 为什么需要两个survivor区

## 有遇到过内存溢出吗？内存溢出是哪部分溢出？怎么避免？

## JDK8 默认的垃圾回收器是什么？

## 如何自己实现内存分配和管理？

不太懂，然后说了jvm的垃圾回收机制