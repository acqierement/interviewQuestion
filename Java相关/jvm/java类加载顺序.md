# java类加载顺序

## 类首次加载顺序

注意这里说的是首次加载，其中1，2是按照先后顺序加载的。

1. 静态成员变量

2. 静态代码块

3. 非静态成员变量

4. 构造代码块

5. 构造器

注意先加载父类,再加载子类

来看一下简单的例子

父类

```java
public class Parent {
    private static String str = "静态成员变量值";

    static {
        System.out.println("执行父类静态代码块");
        System.out.println("在静态代码块中获取静态成员变量str：" + str);
    }

    {
        System.out.println("父类构造代码块");
    }

    public Parent() {
        System.out.println("父类构造函数");
    }
}

```

子类

```java
public class Son extends Parent {
    static {
        System.out.println("执行子类静态代码块");
    }
    {
        System.out.println("执行子类构造代码块");
    }
    public Son() {
        System.out.println("执行子类构造函数");
    }
}
```

测试类

```java
public class test {
    public static void main(String[] args) {
        Son a = new Son();
        System.out.println("------第二次加载-------");
        Son b = new Son();
    }
}
```

结果

```
执行父类静态代码块
在静态代码块中获取静态成员变量str：静态成员变量值
执行子类静态代码块
父类构造代码块
父类构造函数
执行子类构造代码块
执行子类构造函数
------第二次加载-------
父类构造代码块
父类构造函数
执行子类构造代码块
执行子类构造函数
```

我们先来看看第一次加载的过程。我们创建的是子类对象，但是需要先加载父类。一个类编译后就是一个.class文件，jvm第一次加载类需要先初始化一些信息。我们代码的顺序是静态成员变量在前，静态代码块在后，在静态代码块中获取静态成员变量，可以看到没有出错。但是如果调换顺序就报错了，因为此时你在静态代码块里无法引用后面定义的静态变量的值。

这样一个基本的类初始化就好了，注意这里构造方法不算初始化，后面才调用它。父类初始化好了，就到子类初始化了，这里子类执行了静态代码块。所以这些算是第一次类加载的初始化部分。

然后我们需要调用子类的构造函数，调用子类的构造函数之前会先调用父类的构造函数。对了，这里还有一个构造代码块，我不太了解构造代码块，但是从结果来看，构造代码块不属于类初始化的部分，在调用构造函数之前会先执行构造代码块。

第二次new的时候，我们知道new是创建一个实例，之前我只知道创建实例会先调用构造函数，但是现在又知道了一个，创建实例会先执行构造代码块，再去调用构造函数。而且如果有父类的话，会先执行父类的构造代码块和构造函数，再执行子类的构造代码块和构造函数。

但是我现在觉得构造代码块的顺序有点神奇，我的认识是子类的构造函数其实会隐性调用父类的无参构造函数，就像这样：

```java
    public Son() {
        // 这样只会执行一次父类的构造函数，所以可以理解成会隐性地调用super()
        super();
        // 那按照构造代码块的顺序，构造代码块应该在这个地方执行
        System.out.println("执行子类构造函数");
    }
```

所以可以这么理解，执行构造函数会先调用父类的构造函数，然后再执行构造代码块，最后再执行构造函数里的程序。