网络IO模型

常见的网络 IO 模型分为五种：同步阻塞 IO（BIO）、同步非阻塞 IO（NIO）、信号驱动的IO模型，IO 多路复用和异步非阻塞 IO（AIO）。这些 IO 模型中，只有 AIO 为异步 IO，其他都是同步 IO。

## 1. 同步阻塞 IO（blocking IO）

进程发起IO系统调用后，进程被阻塞，转到内核空间处理，整个IO处理完毕后返回进程。操作成功则进程获取到数据。

**优点是：进程阻塞挂起不消耗CPU资源，及时响应每个操作**

缺点就是：

因为一个请求IO会阻塞进程，所以，得为每请求分配一个处理进程（线程）以及时响应，系统开销大。

只能适用于并发量小，业务逻辑只需要同步的场景。

## 2. 同步非阻塞IO（NIO）

进程发起IO系统调用后，如果内核缓冲区有数据，内核就会把数据返回进程。如果内核缓冲区没有数据，需要到IO设备中读取，进程返回一个错误而不会被阻塞

**特点：进程轮询（重复）调用，消耗CPU的资源**；

这种io模型使用比较少

## 3. IO 多路复用（IO multiplexing）

多路复用 IO 是在高并发场景中使用最为广泛的一种 IO 模型，如 Java 的 NIO、Redis、Nginx 的底层实现就是此类 IO 模型的应用，经典的 Reactor 模式也是基于此类 IO 模型。

那么什么是 IO 多路复用呢？通过字面上的理解，多路就是指多个通道，也就是多个网络连接的 IO，而复用就是指多个通道复用在一个复用器上。

多个网络连接的 IO 可以注册到一个复用器（select）上，当用户进程调用了 select，那么整个进程会被阻塞。同时，内核会“监视”所有 select 负责的 socket，当任何一个 socket 中的数据准备好了，select 就会返回。这个时候用户进程再调用 read 操作，将数据从内核中拷贝到用户进程。

**特点**：可以在同一个线程内同时处理多个 IO 请求

## 4. 信号驱动IO模型

 当进程发起一个IO操作，会向内核注册一个信号处理函数，然后进程返回不阻塞；当内核数据就绪时会发送一个信号给进程，进程便在信号处理函数中调用IO读取数据。

**特点**：**回调机制，**实现、开发应用难度大；

## 5. 异步IO模型

  当进程发起一个IO操作，进程返回（不阻塞），但也不能返回结果；内核把整个IO处理完后，会通知进程结果。**如果IO操作成功则进程直接获取到数据**。

**特点：**

不阻塞，数据一步到位**；**Proactor模式；

需要操作系统的底层支持，LINUX 2.5 版本内核首现，2.6 版本产品的内核标准特性；

实现、开发应用难度大；

非常适合高性能高并发应用；