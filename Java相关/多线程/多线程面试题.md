# 多线程面试题

## 基础知识

### 进程 、 线程 、 协程 的含义和区别 

用过线程么，你的项目哪里用到了线程，顿时有点懵逼，线程和进程的区别，线程和进程的关系是怎么样的，是继承吗？。

**进程**就是应用程序的启动实例。比如我们运行一个游戏，打开一个软件，就是开启了一个进程。

进程拥有代码和打开的文件资源、数据资源、独立的内存空间。

**线程**从属于进程，是程序的实际执行者。一个进程至少包含一个主线程，也可以有更多的子线程。

线程拥有自己的栈空间。

**对操作系统来说，线程是最小的执行单元，进程是最小的资源管理单元。**

**协程**，英文Coroutines，是一种比线程更加轻量级的存在。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。

最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。

这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。

### 线程的状态

在 Java 5 以后，线程状态被明确定义在其公共内部枚举类型 java.lang.Thread.State 中，分别是：

new ,runnalbe , wait , time-wait , block , terminated 

### 原子性，可见性与有序性

原子性：所谓的原子性就是指该操作不可再分，要么全部完成，要么全部不完成

可见性：线程1改变了变量的值，线程2知道，就叫可见。所以可见性就是线程之间操作共同变量的时候，彼此都知道。

有序性：按顺序执行。

### 进程间通信方式

管道 、FIFO 、 信号量 、 共享内存 、 消息队列 、 Socket 

### Sleep和wait的区别

怎么唤醒进而引发了锁的概念

- 最主要是sleep方法没有释放bai锁，而wait方法释放了锁
- wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用
- sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常
- sleep是Thread类的静态方法，wait是Object的方法



**wait**的作用是使当前执行代码的线程进行等待，wait()方法是Object类的方法。

在调用wait()之前，线程必须获得该对象的对象级别锁，即只能在同步方法和同步代码块中调用wait()方法。在执行wait()方法后，当前线程释放锁。如果调用wait()方法时没有持有适当的锁，则抛出IllegalMonitorStateException异常，该异常是RuntimeException的子类，所以不需要显式捕获。

### 实现多线程的几种方法，callable与其他两种的区别

1. 继承Thread类，重写run方法。（run是Runnable的抽象方法，Thread有重写了一个方法，所以如果不重写run方法，会执行Tread的方法）
2. 通过实现Runnable接口，实现run方法。将Runnable的实例作为Thread的构造参数，然后调用Thread的start()方法。
3. 实现Callable接口，实现call方法。

**Callable使用方法**

```java
        Callable<String> myCallable = new MyCallable();
        FutureTask<String> futureTask = new FutureTask<String>(myCallable);
        Thread thread = new Thread(futureTask);
        thread.start();
```

#### 使用的时候有什么场景约束

前两种没有返回值，后面一种有返回值

### lock和tryLock区别

- 给他唠了一个acquire这个，但是唠的不明白

lock拿不到锁会一直等待。tryLock是去尝试，**拿不到就返回false，拿到返回true。**

lock不能被中断，tryLock是可以被中断。

lock的详细操作可以看这篇文章[一步步透彻理解Lock的Acquire和Release原理源](https://www.jianshu.com/p/e4301229f59e)

```java
        final void lock() {
            if (compareAndSetState(0, 1))
                setExclusiveOwnerThread(Thread.currentThread());
            else
                acquire(1);
        }
```

```java
    public final void acquire(int arg) {
        if (!tryAcquire(arg) &&
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
```

大于0表示获取锁。如果不是0，就执行acquire去获取锁。

先执行tryAcquire判断状态是否为0，是否是当前线程。如果不是，则执行后半部分，先addWaiter在等待队列尾巴加一个独占模式的节点。

acquireQueued判断是否是头结点，并且能否获得锁，如果可以就返回false，表示不需要阻塞。如果不是头节点，就一直阻塞着。等待其他线程唤醒。

## 乐观锁和悲观锁的实现

乐观锁：版本号和CAS

ABA问题：可以使用版本号避免

java解决ABA的方法：

**AtomicStampedReference** 本质是有一个int 值作为版本号，每次更改前先取到这个int值的版本号，等到修改的时候，比较当前版本号与当前线程持有的版本号是否一致，如果一致，则进行修改，并将版本号+1（当然加多少或减多少都是可以自己定义的），在zookeeper中保持数据的一致性也是用的这种方式；

**AtomicMarkableReference**则是将一个boolean值作是否有更改的标记，本质就是它的版本号只有两个，true和false，修改的时候在这两个版本号之间来回切换，这样做并不能解决ABA的问题，只是会降低ABA问题发生的几率而已；

### CAS原理，ABA问题，解决方法

### java里面并发有什么无锁的方式吗？CAS操作

 CAS是一个什么原理呢？乐观锁

java里面哪里用到了CAS呢？

Atomic相关类，比如AtomicInteger

## 如何避免死锁 ？ 死锁的四个必要条件

互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。

请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。

不可剥夺条件:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。

循环等待条件: 若干进程间形成首尾相接循环等待资源的关系

**避免死锁的方法**

对于以上 4 个条件，只要破坏其中一个条件，就可以避免死锁的发生。

对于第一个条件 "互斥" 是不能破坏的，因为加锁就是为了保证互斥。

其他三个条件，我们可以尝试

- 一次性申请所有的资源，破坏 "请求与保持" 条件
-  占有部分资源的线程进一步申请其他资源时，如果申请不到，主动释放它占有的资源，破坏 "不可剥夺" 条件
-  按序申请资源，破坏 "循环等待" 条件

### 银行家算法是什么；

[计算机操作系统_银行家算法](https://blog.csdn.net/qq_36260974/article/details/84404369)

​		在银行中，客户申请贷款的数量是有限的，每个客户在第一次申请贷款时要声明完成该项目所需的最大资金量，在满足所有贷款要求时，客户应及时归还。银行家在客户申请的贷款数量不超过自己拥有的最大值时，都应尽量满足客户的需要。在这样的描述中，银行家就好比操作系统，资金就是资源，客户就相当于要申请资源的进程。
　　银行家算法是一种最有代表性的避免死锁的算法。在避免死锁方法中允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次分配资源的安全性，若分配不会导致系统进入不安全状态，则分配，否则等待。

## synchronized，volatile关键字

### Sychronized 用法和实现原理

- `synchronized`关键字可以加在`static`方法上吗？锁的是什么？
  可以，锁的是`Class`对象
- `synchronized`关键字加在非`static`方法上时锁的是什么？
  锁的是类的实例

### volatile的作用

指令重拍 、 保证变量的可见性（涉及JMM）

## Sychronized 和 lock 的区别 ？如何选择

1. Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；

2. synchronize是一个重入锁，而且是非公平锁，lock可以设置是否公平。

3. synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；

4. Lock有tryLock方法，可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；

5. 通过Lock的tryLock可以知道有没有成功获取锁，而synchronized却无法办到。

   > 在高版本JDK中，已经对synchronized进行了优化，synchronized和Lock方式在性能方面差别已不太明显

### Sychronized的底层优化 ： { 无锁、偏向锁、轻量级锁 、重量级锁 }

synchronized的锁升级过程

Java 中的锁，自旋锁会升级成什么？

### ReentrantLock 用法和实现原理

讲了“可重入”的概念及实现方式以及`lock`、`tryLock`、`unlock`等基本的方法，以及使用这些方法实现一个简单的自旋锁的原理
  **Tip：ConcurrentHashMap在Java 7及以前使用的是可重入锁，不妨了解一下其如何使用可重入锁来实现线程安全**  

问题：

互斥量、读写锁、自旋锁、条件变量

## ThreadLocal的实现原理

##  AQS 框架原理和 源码理解

AQS底层实现，与ReentrantLock的关系

## servlet是线程安全的么

每个servlet在Tomcat容器中只有一个实例对象，即是单例模式

如果多个HTTP请求请求的是同一个Servlet，那么会并发执行Servlet的service()方法，所以不是如果有改数据，比如i++,这样就可能造成数据不一致。

## 多线程情况下临界区的资源保护有哪些方式？

比如锁）



## 并发包，原子引用啊，原子类啊什么的Integer等也可以保证线程安全，知道cas线程的关系，compare and set

## 讲了一下`ConcurrentHashMap`、`ReentrantLock`、`ThreadPoolExecutor`、`AtomicInteger`

`ConcurrentHashMap`线程安全是如何实现的？

## 【todo】线程池

### 介绍一下线程池

线程池构造器涉及哪些参数 : { corePoolSize , maximumPoolSzie , timeout ， timeUnit ， RejectHandler ， 等待队列 ， 线程工厂 }   

如何确定线程池中线程的个数等

介绍线程池工作过程? 

线程池拒绝策略那些？

 适用Executor创建线程池的弊端？

### 线程池的任务策略为什么要设计成现在这样

### 线程池的拒绝策略

### 定时线程池如何实现的？

### 线程池参数，execute()，里面那个是实现了什么接口

### 用过什么线程池，使用Fixed的线程池时如果一个线程出现异常，那么核心线程会发生什么变化

## 【todo】lock的公平锁和非公平锁的怎么实现的（源码级别），不限于概念

公平锁和非公平锁的区别，源码级别

面试官补充：非公平锁就是抢占式的嘛

## juc看过哪些，说AQS的机制

讲讲JUC包下的内容（计数器，循环栅栏，信号量）

讲讲ArrayBlockingQueue

## Lock如果给线程分配锁的

叭叭ReentrantLock

## 多线程如何实现主存同步的

缓存一致性扯一扯，Java内存模型

## 那通过什么指令去实现其他工作内存无效的

## Java里怎么实现缓存一致性的

volatile、synchronized、lock、信号量、wait/notify

面试官补充：信号量也是加锁实现的

## 原子类你用过吗？

用过，AtomicInteger，底层是用的CAS实现的

1. CAS怎么实现的
   - CAS是jdk8 unsafe类实现，jdk9 是VarHandle实现
   - CAS是在openjdk用unsafe.cpp实现的
2. CAS本质性实现原理是什么？
   - 说了V- A-B
   - 是这样吗？
   - cas主要应用在哪

## 如果线程异常如何通知用户

## 线程同步方法



## 成员变量i，用sychronized包括的i++线程安全吗（多次提示）

 如何保证i++安全

## threadlocal做缓存的场景

ThreadLocal的key是什么，常用场景

工作中用到ThreadLocal的场景

## threadlocal的实现原理



## 分布式锁的优缺点

## 并发了解多少？线程之间怎样控制并发。线程之间如何同步，控制并发中的锁有了解吗？

## 代码测试(n个线程循环轮流打印自己的id:123123123这种)

**TestThread.java**

```java
public class TestThread extends Thread {
    private int id = 1;
    volatile static int num = 0;
    TestThread(int id) {
        this.id = id;
    }
    @Override
    public void run() {
        synchronized (TestThread.class) {
            while (true) {
                if (num % 10 + 1 == id) {
                    System.out.println(id);
                    num++;
                    TestThread.class.notifyAll();
                } else {
                    try {
                        TestThread.class.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }
}
```

测试代码

```java
public class MainTest {
    public static void main(String[] args) {
        for (int i = 1; i <= 10; i++) {
            TestThread testThread = new TestThread(i);
            testThread.start();
        }
    }
}
```

## 怎么使主线程等待另一个线程完成后再执行

第一种 **join**。

第二种 **CountDownLatch**

主要使用countDown()和await()方法

```java
public class CountDownLatchThread extends Thread{
    private CountDownLatch countDownLatch;
    CountDownLatchThread(CountDownLatch countDownLatch) {
        this.countDownLatch  = countDownLatch;
    }
    @Override
    public void run() {
        System.out.println("开始执行子线程方法");
        try {
            Thread.sleep(4000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        countDownLatch.countDown();
        System.out.println("子线程方法执行完毕，耗时四秒");

    }
}
// 测试方法
public class MainTest {
    public static void main(String[] args) throws InterruptedException {
        CountDownLatch countDownLatch = new CountDownLatch(1);
        CountDownLatchThread thread = new CountDownLatchThread(countDownLatch);
        thread.start();
        countDownLatch.await();
        System.out.println("主线程执行完毕");
    }
}
```



还有呢？还有呢？连环问

## 多进程数据落库怎么协调

分布式事务、分布式锁、消息队列异步化

## 两个线程，一个线程打印奇数，一个打印偶数，控制交替打印奇偶数。

(有多种方法实现，最好能比较优劣)

## 如果sleep(0)会怎样（降低优先级）

触发操作系统立刻重新进行一次CPU竞争

[Thread.sleep(0) 有什么用？](https://blog.csdn.net/z69183787/article/details/106719171/)

## 程序出现死锁时，CPU和内存的变化

如果死锁，是自旋锁的话，会占用cpu资源，cup会飙升

## 程序出现死锁如何进行定位，如何解决

（答的不是很好，回答了用jstack定位代码，并应该尽量提前避免死锁，比如使用tryLock之类带时间限制的）

## 一个程序，while(true){new Thread().start()}运行会发生什么

（不是很清楚，回答了抛异常，应该会堆或者栈溢出，但是下来跑程序什么也没抛，好像是JVM1.8限制了最大创建线程数量？）

## 