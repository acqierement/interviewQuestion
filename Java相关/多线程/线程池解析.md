# çº¿ç¨‹æ± è§£æ

ä»¥jdk1.8æ¥çœ‹

## æ„é€ å‚æ•°

æ¥çœ‹ä¸€ä¸‹çº¿ç¨‹æ± å‚æ•°æœ€å¤šçš„ä¸€ä¸ªæ„é€ å‡½æ•°ï¼š

```java
    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
```

**corePoolSize**ï¼šè¡¨ç¤ºçº¿ç¨‹æ± ä¿æœ‰çš„æœ€å°çº¿ç¨‹æ•°ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œåœ¨åˆ›å»ºäº†çº¿ç¨‹æ± åï¼Œçº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹æ•°ä¸º0ï¼Œå½“æœ‰ä»»åŠ¡æ¥ä¹‹åï¼Œå°±ä¼šåˆ›å»ºä¸€ä¸ªçº¿ç¨‹å»æ‰§è¡Œä»»åŠ¡ï¼ˆå³ä½¿ç°åœ¨æœ‰ç©ºé—²çš„çº¿ç¨‹ï¼Œä¹Ÿä¼šå»åˆ›å»ºï¼‰ï¼Œå½“çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹æ•°ç›®è¾¾åˆ°corePoolSizeåï¼Œå°±ä¼šæŠŠåˆ°è¾¾çš„ä»»åŠ¡æ”¾åˆ°ç¼“å­˜é˜Ÿåˆ—å½“ä¸­ã€‚

**maximumPoolSize**ï¼šè¡¨ç¤ºçº¿ç¨‹æ± åˆ›å»ºçš„æœ€å¤§çº¿ç¨‹æ•°ã€‚å¦‚æœæ‰€æœ‰çš„çº¿ç¨‹éƒ½åœ¨å¿™ï¼Œå¹¶ä¸”å·¥ä½œé˜Ÿåˆ—æ”¾ä¸ä¸‹ï¼Œå°±ä¼šåˆ›å»ºæ–°çš„çº¿ç¨‹ï¼Œä½†ä¸èƒ½è¶…è¿‡æœ€å¤§çº¿ç¨‹ï¼Œè¶…è¿‡ä¼šæ‹’ç»ğŸ™…ã€‚

**keepAliveTime & unitï¼š**è¡¨ç¤ºçº¿ç¨‹æ²¡æœ‰ä»»åŠ¡æ‰§è¡Œæ—¶æœ€å¤šä¿æŒå¤šä¹…æ—¶é—´ä¼šç»ˆæ­¢ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œå½“çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹æ•°å¤§äºcorePoolSizeæ—¶ï¼Œå¦‚æœæŸä¸ªçº¿ç¨‹çš„ç©ºé—²æ—¶é—´è¶…è¿‡äº†å­˜æ´»æ—¶é—´ï¼Œé‚£ä¹ˆå°†è¢«æ ‡è®°ä¸ºå¯å›æ”¶ï¼Œè¿™ä¸ªçº¿ç¨‹å°†è¢«ç»ˆæ­¢ã€‚

**workQueue**ï¼šå·¥ä½œé˜Ÿåˆ—ã€‚

**threadFactory**ï¼šçº¿ç¨‹å·¥å‚ï¼Œå¯ä»¥è‡ªå®šä¹‰åˆ›å»ºçº¿ç¨‹ã€‚ä¾‹å¦‚ç»™çº¿ç¨‹è®¾ç½®åå­—ã€‚

**handler**ï¼šè¡¨ç¤ºå½“æ‹’ç»å¤„ç†ä»»åŠ¡æ—¶çš„ç­–ç•¥ã€‚å¦‚æœæ‰€æœ‰çº¿ç¨‹éƒ½åœ¨å¿™ç¢Œï¼Œå¹¶ä¸”å·¥ä½œé˜Ÿåˆ—ä¹Ÿæ»¡äº†ï¼Œæ­¤æ—¶æäº¤ä»»åŠ¡ä¼šè¢«æ‹’ç»ï¼Œæœ‰å››ç§æ‹’æ¥ç­–ç•¥ã€‚

## çº¿ç¨‹æ± çš„æ‹’ç»ç­–ç•¥

```
ThreadPoolExecutor.AbortPolicy:ä¸¢å¼ƒä»»åŠ¡å¹¶æŠ›å‡ºRejectedExecutionExceptionå¼‚å¸¸ã€‚ 
ThreadPoolExecutor.DiscardPolicyï¼šä¹Ÿæ˜¯ä¸¢å¼ƒä»»åŠ¡ï¼Œä½†æ˜¯ä¸æŠ›å‡ºå¼‚å¸¸ã€‚ 
ThreadPoolExecutor.DiscardOldestPolicyï¼šä¸¢å¼ƒé˜Ÿåˆ—æœ€å‰é¢çš„ä»»åŠ¡ï¼Œç„¶åé‡æ–°å°è¯•æ‰§è¡Œä»»åŠ¡ï¼ˆé‡å¤æ­¤è¿‡ç¨‹ï¼‰
ThreadPoolExecutor.CallerRunsPolicyï¼šç”±è°ƒç”¨çº¿ç¨‹å¤„ç†è¯¥ä»»åŠ¡ 
```

Javaåœ¨1.6ç‰ˆæœ¬è¿˜å¢åŠ äº† allowCoreThreadTimeOut(boolean value) æ–¹æ³•ã€‚å¦‚æœæ‰€æœ‰çš„çº¿ç¨‹éƒ½ç©ºé—²ï¼Œå°±å–æ¶ˆæ‰€æœ‰çº¿ç¨‹ã€‚

## çº¿ç¨‹æ± çš„çŠ¶æ€

ThreadPoolExecutorç±»æ³¨é‡Šå°±å†™äº†ç›¸å…³çš„çŠ¶æ€

RUNNINGï¼šæ¥æ”¶æ–°çš„ä»»åŠ¡å¹¶å¤„ç†æ’é˜Ÿçš„ä»»åŠ¡

SHUTDOWNï¼šä¸å†æ¥å—æ–°çš„ä»»åŠ¡ï¼Œä½†ä»ç„¶å¤„ç†æ’é˜Ÿçš„ä»»åŠ¡ã€‚

STOPï¼šä¸å†æ¥å—æ–°çš„ä»»åŠ¡ï¼Œä¹Ÿä¸å¤„ç†æ’é˜Ÿçš„ä»»åŠ¡ï¼Œå¹¶ä¸”ä¼šä¸­æ–­æ­£åœ¨è¿›è¡Œçš„ä»»åŠ¡ã€‚

TIDYINGï¼šæ‰€æœ‰çš„ä»»åŠ¡éƒ½ç»ˆæ­¢äº†ï¼Œå¹¶ä¸”çº¿ç¨‹æ•°ä¸º0ï¼Œæ­£åœ¨è½¬æ¢åˆ°TIDYINGçŠ¶æ€çš„çº¿ç¨‹ä¼šæ‰§è¡Œterminated()æ–¹æ³•ã€‚

TERMINATEDï¼šterminated()æ–¹æ³•å·²ç»æ‰§è¡Œå®Œäº†ã€‚

## ä»‹ç»çº¿ç¨‹æ± å·¥ä½œè¿‡ç¨‹? 

ç›´æ¥æ¥çœ‹çœ‹æºç 

ThreadPoolExecutor ç»§æ‰¿AbstractExecutorServiceï¼ŒAbstractExecutorServiceå®ç°ExecutorServiceæ¥å£ï¼ŒExecutorServiceæ¥å£å®ç°Executoræ¥å£ã€‚Executoræ¥å£é‡Œé¢åªæœ‰executeæ–¹æ³•ã€‚

ThreadPoolExecutorç±»ä¸­æ‰§è¡Œçš„ä¸»è¦çš„æ–¹æ³•æœ‰execute()å’Œsubmit()æ–¹æ³•ã€‚submit()æ–¹æ³•çš„å®ç°ï¼Œä¼šå‘ç°å®ƒå®é™…ä¸Šè¿˜æ˜¯è°ƒç”¨çš„execute()æ–¹æ³•ï¼Œåªä¸è¿‡å®ƒåˆ©ç”¨äº†Futureæ¥è·å–ä»»åŠ¡æ‰§è¡Œç»“æœã€‚

æ‰€ä»¥æˆ‘ä»¬ä¸»è¦æ¥çœ‹çœ‹execute()æ–¹æ³•ï¼š

```java
    public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
		// ctlæ˜¯AtomicIntegerï¼Œè¿™ä¸ªå€¼çš„é«˜ä½å­˜çš„æ˜¯çº¿ç¨‹æ± çš„çŠ¶æ€ï¼Œä½ä½å­˜çš„æ˜¯çº¿ç¨‹çš„ä¸ªæ•°
        int c = ctl.get();
        //å¦‚æœå½“å‰çº¿ç¨‹æ•°å°äºcorePoolSizeï¼Œå°±å¼€å¯ä¸€ä¸ªçº¿ç¨‹æ¥æ‰§è¡Œè¿™ä¸ªcommandï¼ˆå¯¹åº”addWorkeræ–¹æ³•ï¼‰
        if (workerCountOf(c) < corePoolSize) {
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        // åˆ¤æ–­æ˜¯è¿è¡ŒçŠ¶æ€å¹¶ä¸”èƒ½æˆåŠŸåŠ å…¥åˆ°workQueueé‡Œ
        if (isRunning(c) && workQueue.offer(command)) {
            //å¦‚æœåŠ å…¥è¿›å»åï¼Œéœ€è¦å†æ¬¡æ£€æŸ¥çŠ¶æ€ï¼Œå› ä¸ºå­˜åœ¨ç¬¬ä¸€æ¬¡æ£€æŸ¥åçº¿ç¨‹æ± å¯èƒ½æ˜¯å…³é—­çš„æƒ…å†µ
            int recheck = ctl.get();
            if (! isRunning(recheck) && remove(command))
                reject(command);
            //åˆ¤æ–­æ˜¯å¦çº¿ç¨‹ä¸º0ï¼Œå¦åˆ™è¦åŠ ä¸€ä¸ª
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        //å¦‚æœä¸æ˜¯ä»¥ä¸Šçš„æƒ…å†µï¼Œå°±ç›´æ¥åŠ ä¸€ä¸ªworkerï¼Œå¦‚æœå¤±è´¥äº†ï¼Œå°±æ‹’ç»ã€‚
        else if (!addWorker(command, false))
            reject(command);
    }
```

æ‰€ä»¥æ€»ç»“ä¸€ä¸‹å‰é¢å¤§ä½“çš„æ­¥éª¤ï¼š

1. å¦‚æœçº¿ç¨‹æ•°å°äºcorePoolSizeï¼Œå°±å¼€å¯ä¸€ä¸ªçº¿ç¨‹å»æ‰§è¡Œä»»åŠ¡ã€‚
2. å¦‚æœçº¿ç¨‹æ•°å¤§äºç­‰äºcorePoolSizeï¼Œåˆ™å°è¯•å°†å…¶åŠ å…¥å·¥ä½œé˜Ÿåˆ—ï¼Œç­‰å¾…ç©ºé—²çº¿ç¨‹æ‰§è¡Œã€‚åŠ å…¥æˆåŠŸåï¼Œè¿˜è¦å†è¿›è¡Œæ£€æŸ¥ï¼Œä»¥é˜²æ­¢çº¿ç¨‹æˆ–çº¿ç¨‹æ± å…³é—­çš„æƒ…å†µã€‚
3. å¦‚æœåŠ å…¥å·¥ä½œé˜Ÿåˆ—å¤±è´¥ï¼ˆå¤±è´¥åŸå› é€šå¸¸æ˜¯é˜Ÿåˆ—æ»¡äº†ï¼‰ï¼Œå¦‚æœè¿™æ ·ï¼Œå°±æ–°å»ºä¸€ä¸ªçº¿ç¨‹ï¼Œæ–°å»ºçº¿ç¨‹å¦‚æœå¤§äºmaximumPoolSizeï¼Œåˆ™æœ‰å¯èƒ½å¤±è´¥ï¼Œå¤±è´¥çš„è¯å°±æ‰§è¡Œæ‹’ç»ç­–ç•¥ã€‚

ä¸Šé¢ä¸»è¦å°±æ˜¯addWorkeræ–¹æ³•å’Œrejectæ–¹æ³•ã€‚ä¸»è¦è‚¯å®šæ˜¯addWorker()ï¼Œå…ˆæ¥çœ‹çœ‹è¿™ä¸ªä»£ç ã€‚

å…ˆçœ‹çœ‹å‰åŠæ®µï¼š

```java
        retry:
        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);

            // Check if queue empty only if necessary.
            if (rs >= SHUTDOWN &&
                ! (rs == SHUTDOWN &&
                   firstTask == null &&
                   ! workQueue.isEmpty()))
                return false;

            for (;;) {
                int wc = workerCountOf(c);
                if (wc >= CAPACITY ||
                    wc >= (core ? corePoolSize : maximumPoolSize))
                    return false;
                if (compareAndIncrementWorkerCount(c))
                    break retry;
                c = ctl.get();  // Re-read ctl
                if (runStateOf(c) != rs)
                    continue retry;
                // else CAS failed due to workerCount change; retry inner loop
            }
        }
```

ä¸»è¦æ˜¯åˆ¤æ–­å½“å‰æ˜¯å¦èƒ½å¤Ÿæ–°å¢workerã€‚

            if (rs >= SHUTDOWN &&
                ! (rs == SHUTDOWN &&
                   firstTask == null &&
                   ! workQueue.isEmpty()))
                return false;
å…ˆåˆ¤æ–­çŠ¶æ€ä¸æ˜¯runningçš„éƒ½è¿”å›falseï¼Œå…¶ä¸­å­˜åœ¨ä¸€ä¸ªä¾‹å¤–ï¼Œè¿˜è®°å¾—å‰é¢æœ‰ä¸ªä»£ç  ï¼Œå½“çº¿ç¨‹æ•°ä¸º0 çš„æ—¶å€™ï¼Œä¼šaddWorker(null, false)ï¼Œè¿™è¾¹çš„é€»è¾‘ä¸»è¦é’ˆå¯¹è¿™ä¸ªã€‚å¦‚æœçº¿ç¨‹æ˜¯SHUTDOWNï¼Œå¹¶ä¸”firstTask==nullï¼Œé˜Ÿåˆ—ä¸ä¸ºç©ºï¼Œæ‰€ä»¥æ­¤æ—¶è¦å…è®¸å®ƒåŠ ä¸€ä¸ªçº¿ç¨‹ã€‚

ç„¶åæ˜¯åˆ¤æ–­çº¿ç¨‹æ•°ï¼Œå¤§äºæœ€å¤§å€¼ï¼Œæˆ–è€…å¤§äºcorePoolSizeè¿˜æ˜¯maximumPoolSizeä¼šè¿”å›falseã€‚

ç„¶åæ‰æ˜¯æ–°å¢workerï¼šworkerå…¶å®é‡Œé¢å°±æ˜¯å°è£…äº†ä¸€ä¸ªçº¿ç¨‹threadå’Œä¸€ä¸ªRunnableç±»å‹çš„firstTaskå˜é‡ã€‚

```java
        boolean workerStarted = false;
        boolean workerAdded = false;
        Worker w = null;
        try {
            final ReentrantLock mainLock = this.mainLock;
            w = new Worker(firstTask);
            final Thread t = w.thread;
            if (t != null) {
                mainLock.lock();
                try {
                    // Recheck while holding lock.
                    // Back out on ThreadFactory failure or if
                    // shut down before lock acquired.
                    int c = ctl.get();
                    int rs = runStateOf(c);

                    if (rs < SHUTDOWN ||
                        (rs == SHUTDOWN && firstTask == null)) {
                        if (t.isAlive()) // precheck that t is startable
                            throw new IllegalThreadStateException();
                        workers.add(w);
                        int s = workers.size();
                        if (s > largestPoolSize)
                            largestPoolSize = s;
                        workerAdded = true;
                    }
                } finally {
                    mainLock.unlock();
                }
                if (workerAdded) {
                    t.start();
                    workerStarted = true;
                }
            }
        } finally {
            if (! workerStarted)
                addWorkerFailed(w);
        }
        return workerStarted;
```

è¿™è¾¹å°±æ˜¯æ–°å»ºä¸€ä¸ªworkerï¼Œæ–°å»ºä¸€ä¸ªçº¿ç¨‹ï¼Œå°†å½“å‰ä»»åŠ¡å½“åšç¬¬ä¸€ä¸ªä»»åŠ¡æ‰§è¡Œï¼Œç„¶ååˆ¤æ–­ä¸€ä¸‹çŠ¶æ€æ˜¯å¦ç¬¦åˆï¼Œç¬¦åˆçš„è¯å°±åŠ å…¥åˆ°workersä¸­ï¼Œä¸ç¬¦åˆçš„è¯å°±æ‰§è¡ŒaddWorkerFailed(w)ã€‚

**addWorkerFailed**

```
    /**
     * Rolls back the worker thread creation.
     * - removes worker from workers, if present
     * - decrements worker count
     * - rechecks for termination, in case the existence of this
     *   worker was holding up termination
     */
     // ç§»é™¤ä»»åŠ¡ï¼Œå‡workeræ•°é‡ï¼Œå¯¹terminationè¿›è¡Œæ£€æŸ¥
    private void addWorkerFailed(Worker w) {
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            if (w != null)
                workers.remove(w);
            decrementWorkerCount();
            tryTerminate();
        } finally {
            mainLock.unlock();
        }
    }
```

ç„¶åçœ‹ä¸€ä¸‹reject()ï¼Œå°±æ˜¯æ‰§è¡Œå„ä¸ªæ‰§è¡Œç­–ç•¥çš„rejectedExecutionæ–¹æ³•ã€‚

```java
    final void reject(Runnable command) {
        handler.rejectedExecution(command, this);
    }
```

## å¦‚ä½•ç¡®å®šçº¿ç¨‹æ± ä¸­çº¿ç¨‹çš„ä¸ªæ•°

ã€Šjavaå¹¶å‘ç¼–ç¨‹å®æˆ˜ã€‹æœ‰æåˆ°ï¼š

å‡è®¾è®¡ç®—æœºæœ‰Nä¸ªcpuã€‚

å¯¹äºè®¡ç®—å¯†é›†å‹ä»»åŠ¡ï¼Œçº¿ç¨‹çš„å¤§å°åº”è¯¥ä¸ºN+1;

å¯¹äºI/Oæ“ä½œæˆ–è€…å…¶ä»–é˜»å¡çš„ä»»åŠ¡ã€‚ä½ å¿…é¡»ä¼°ç®—å‡ºä»»åŠ¡çš„ç­‰å¾…æ—¶é—´ä¸è®¡ç®—æ—¶é—´çš„æ¯”å€¼ï¼ˆW/Cï¼‰

çº¿ç¨‹çš„å¤§å°åº”è¯¥ä¸º N \* CPUä½¿ç”¨ç‡ \* (1 + W/C)ã€‚

æœ‰ä¸€ç§è¯´æ³•ï¼š`å¦‚æœæ˜¯IOå¯†é›†å‹ä»»åŠ¡ï¼Œå‚è€ƒå€¼å¯ä»¥è®¾ç½®ä¸º2**N*CPUã€‚`æˆ‘ä»¬å‡å®šã€Šjavaå¹¶å‘ç¼–ç¨‹å®æˆ˜ã€‹ä¸­çš„è¯´æ³•æ˜¯æ­£ç¡®çš„ï¼Œé‚£ä¹ˆå¯¹åº”ä¹¦ä¸­çš„å…¬å¼ï¼Œè¿™ç§è¯´æ³•å°±è¡¨ç¤ºW/Cç­‰äº1ï¼Œä¹Ÿå°±æ˜¯å‡ ä¹æ²¡æœ‰éœ€è¦è®¡ç®—çš„æ“ä½œï¼Œè¿™ç§æƒ…å†µæ˜¯ä¸ç¬¦åˆå®é™…çš„ã€‚

## ä½¿ç”¨Executoråˆ›å»ºçº¿ç¨‹æ± çš„å¼Šç«¯ï¼Ÿ

ä¸å»ºè®®ä½¿ç”¨Executorsçš„æœ€é‡è¦çš„åŸå› æ˜¯ï¼šExecutorsæä¾›çš„å¾ˆå¤šæ–¹æ³•é»˜è®¤ä½¿ç”¨çš„éƒ½æ˜¯æ— ç•Œçš„
LinkedBlockingQueueï¼Œé«˜è´Ÿè½½æƒ…å¢ƒä¸‹ï¼Œæ— ç•Œé˜Ÿåˆ—å¾ˆå®¹æ˜“å¯¼è‡´OOMï¼Œè€ŒOOMä¼šå¯¼è‡´æ‰€æœ‰è¯·æ±‚éƒ½æ— æ³•å¤„ç†ï¼Œ
è¿™æ˜¯è‡´å‘½é—®é¢˜ã€‚æ‰€ä»¥**å¼ºçƒˆå»ºè®®ä½¿ç”¨æœ‰ç•Œé˜Ÿåˆ—**ã€‚

1ï¼‰newFixedThreadPoolå’ŒnewSingleThreadExecutor:
â€ƒâ€ƒä¸»è¦é—®é¢˜æ˜¯å †ç§¯çš„è¯·æ±‚å¤„ç†é˜Ÿåˆ—å¯èƒ½ä¼šè€—è´¹éå¸¸å¤§çš„å†…å­˜ï¼Œç”šè‡³OOMã€‚

2ï¼‰newCachedThreadPoolå’ŒnewScheduledThreadPool:
â€ƒâ€ƒä¸»è¦é—®é¢˜æ˜¯çº¿ç¨‹æ•°æœ€å¤§æ•°æ˜¯Integer.MAX_VALUEï¼Œå¯èƒ½ä¼šåˆ›å»ºæ•°é‡éå¸¸å¤šçš„çº¿ç¨‹ï¼Œç”šè‡³OOMã€‚

## å¦‚æœä¸€ä¸ªçº¿ç¨‹å‡ºç°å¼‚å¸¸ï¼Œé‚£ä¹ˆæ ¸å¿ƒçº¿ç¨‹ä¼šå‘ç”Ÿä»€ä¹ˆå˜åŒ–

æ‰§è¡Œæ–¹æ³•ä¸»è¦åœ¨workerå†…éƒ¨ç±»é‡Œé¢çš„runWorkeræ–¹æ³•

```java
final void runWorker(Worker w) {
        Thread wt = Thread.currentThread();
        Runnable task = w.firstTask;
        w.firstTask = null;
        w.unlock(); // allow interrupts
        boolean completedAbruptly = true;
        try {
            while (task != null || (task = getTask()) != null) {
                w.lock();
                // If pool is stopping, ensure thread is interrupted;
                // if not, ensure thread is not interrupted.  This
                // requires a recheck in second case to deal with
                // shutdownNow race while clearing interrupt
                if ((runStateAtLeast(ctl.get(), STOP) ||
                     (Thread.interrupted() &&
                      runStateAtLeast(ctl.get(), STOP))) &&
                    !wt.isInterrupted())
                    wt.interrupt();
                try {
                    beforeExecute(wt, task);
                    Throwable thrown = null;
                    try {
                        task.run();
                    } catch (RuntimeException x) {
                        thrown = x; throw x;
                    } catch (Error x) {
                        thrown = x; throw x;
                    } catch (Throwable x) {
                        thrown = x; throw new Error(x);
                    } finally {
                        afterExecute(task, thrown);
                    }
                } finally {
                    task = null;
                    w.completedTasks++;
                    w.unlock();
                }
            }
            completedAbruptly = false;
        } finally {
            processWorkerExit(w, completedAbruptly);
        }
    }
```

å¯ä»¥çœ‹åˆ°ï¼Œåœ¨æœ€åå‡ è¡Œï¼Œå¦‚æœå‡ºç°å¼‚å¸¸ï¼ŒcompletedAbruptly = trueï¼Œè¿™æ—¶ä¼šè°ƒç”¨processWorkerExitæ–¹æ³•

```java
 private void processWorkerExit(Worker w, boolean completedAbruptly) {
        if (completedAbruptly) // If abrupt, then workerCount wasn't adjusted
            decrementWorkerCount();

        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            completedTaskCount += w.completedTasks;
            workers.remove(w);
        } finally {
            mainLock.unlock();
        }

        tryTerminate();

        int c = ctl.get();
        if (runStateLessThan(c, STOP)) {
            if (!completedAbruptly) {
                int min = allowCoreThreadTimeOut ? 0 : corePoolSize;
                if (min == 0 && ! workQueue.isEmpty())
                    min = 1;
                if (workerCountOf(c) >= min)
                    return; // replacement not needed
            }
            addWorker(null, false);
        }
    }
```

å‰é¢å¯ä»¥çœ‹åˆ°ï¼Œä¸ç®¡æ˜¯æ­£å¸¸è¿˜æ˜¯å¼‚å¸¸éƒ½ä¼šè¿›å…¥åˆ°è¿™ä¸ªæ–¹æ³•ã€‚

å¦‚æœå¼‚å¸¸ï¼ŒcompletedAbruptlyç­‰äºtrueã€‚ä¼šå…ˆå‡å»æ•°é‡ï¼Œå†ç§»é™¤çº¿ç¨‹ï¼Œç„¶ååé¢å†åˆ›å»ºä¸€ä¸ªçº¿ç¨‹ã€‚

## å®šæ—¶çº¿ç¨‹æ± å¦‚ä½•å®ç°çš„ï¼Ÿ

å…ˆæ¥çœ‹ä¾‹å­

```java
public class ScheduleTask {  
       
    public static void main(String[] args) { 
        //å½“å‰æ—¶é—´ 
        long start = System.currentTimeMillis();
        //åˆ›å»ºä¸€ä¸ªå•çº¿ç¨‹çš„çº¿ç¨‹æ± 
        ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();  
        // ç¬¬äºŒä¸ªå‚æ•°ä¸ºé¦–æ¬¡æ‰§è¡Œçš„å»¶æ—¶æ—¶é—´ï¼Œç¬¬ä¸‰ä¸ªå‚æ•°ä¸ºå®šæ—¶æ‰§è¡Œçš„é—´éš”æ—¶é—´  
        service.scheduleAtFixedRate(() ->   System.out.println(Thread.currentThread().getName() + "  " +  (System.currentTimeMillis() - start)),
                     1, 1, TimeUnit.SECONDS);  
    }  
}
```

é¦–å…ˆnewSingleThreadScheduledExecutoråˆ›å»ºäº†çº¿ç¨‹æ± 

```java
    public ScheduledThreadPoolExecutor(int corePoolSize) {
        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
              new DelayedWorkQueue());
    }
```

å¯ä»¥çœ‹åˆ°å…¶å·¥ä½œé˜Ÿåˆ—æ˜¯DelayedWorkQueueã€‚è¿™ä¸ªé˜Ÿåˆ—æˆ‘ä»¬åé¢å†æ¥çœ‹

å…ˆæ¥çœ‹çœ‹å¦‚ä½•æ‰§è¡Œçš„

**ScheduledThreadPoolExecutor#scheduleAtFixedRate**

```java
   public ScheduledFuture<?> scheduleAtFixedRate(Runnable command,
                                                  long initialDelay,
                                                  long period,
                                                  TimeUnit unit) {
        if (command == null || unit == null)
            throw new NullPointerException();
        if (period <= 0)
            throw new IllegalArgumentException();
        ScheduledFutureTask<Void> sft =
            new ScheduledFutureTask<Void>(command,
                                          null,
                                          triggerTime(initialDelay, unit),
                                          unit.toNanos(period));
        RunnableScheduledFuture<Void> t = decorateTask(command, sft);
        sft.outerTask = t;
        delayedExecute(t);
        return t;
    }
```

è¿™é‡Œä¸»è¦æ ¹æ®ä¼ è¿›æ¥çš„å‚æ•°å°è£…äº†ScheduledFutureTaskç±»ã€‚

ç„¶åå†çœ‹çœ‹æ‰§è¡ŒdelayedExecute

```java
    private void delayedExecute(RunnableScheduledFuture<?> task) {
        if (isShutdown())
            reject(task);
        else {
            super.getQueue().add(task);
            if (isShutdown() &&
                !canRunInCurrentRunState(task.isPeriodic()) &&
                remove(task))
                task.cancel(false);
            else
                ensurePrestart();
        }
    }

    void ensurePrestart() {
        int wc = workerCountOf(ctl.get());
        if (wc < corePoolSize)
            addWorker(null, true);
        else if (wc == 0)
            addWorker(null, false);
    }
```

å¯ä»¥çœ‹åˆ°æœ€åå°±æ˜¯é€šè¿‡addWorkeråŠ å…¥åˆ°é˜Ÿåˆ—ä¸­ï¼Œè¿™ä¸ªæˆ‘ä»¬ä¹‹å‰å·²ç»è¯´è¿‡äº†ã€‚

æˆ‘ä»¬çŸ¥é“çº¿ç¨‹æ± æ‰§è¡Œçš„æ–¹æ³•ä¸»è¦åœ¨runWorkeræ–¹æ³•ä¸­ï¼Œä¼šé€šè¿‡getTaskæ–¹æ³•å»å·¥ä½œé˜Ÿåˆ—ä¸­æ‹¿åˆ°ä»»åŠ¡ã€‚åœ¨é‚£ä¸ªæ–¹æ³•ä¸­æ˜¯é€šè¿‡é˜Ÿåˆ—çš„takeæ–¹æ³•æ¥è·å¾—é˜Ÿåˆ—çš„ä»»åŠ¡çš„ã€‚

æˆ‘ä»¬æ¥çœ‹çœ‹å‰é¢æåˆ°çš„DelayedWorkQueueçš„takeæ–¹æ³•

```java
        public RunnableScheduledFuture<?> take() throws InterruptedException {
            final ReentrantLock lock = this.lock;
            lock.lockInterruptibly();
            try {
                for (;;) {
                    RunnableScheduledFuture<?> first = queue[0];
                    if (first == null)
                        available.await();
                    else {
                        long delay = first.getDelay(NANOSECONDS);
                        if (delay <= 0)
                            return finishPoll(first);
                        first = null; // don't retain ref while waiting
                        if (leader != null)
                            available.await();
                        else {
                            Thread thisThread = Thread.currentThread();
                            leader = thisThread;
                            try {
                                available.awaitNanos(delay);
                            } finally {
                                if (leader == thisThread)
                                    leader = null;
                            }
                        }
                    }
                }
            } finally {
                if (leader == null && queue[0] != null)
                    available.signal();
                lock.unlock();
            }
        }
```

å‰é¢æ„å»ºRunnableScheduledFutureä»»åŠ¡çš„æ—¶å€™ï¼Œæˆ‘ä»¬ä¼ å…¥äº†å»¶è¿Ÿæ‰§è¡Œçš„æ—¶é—´ï¼Œæ‰€ä»¥è¿™é‡Œå°±å¯ä»¥æ‹¿åˆ°é‚£ä¸ªå»¶è¿Ÿæ—¶é—´ï¼Œç­‰å»¶è¿Ÿæ—¶é—´åˆ°äº†ï¼Œå†è¿”å›ä»»åŠ¡å»æ‰§è¡Œã€‚

é‚£ä¹ˆé—´éš”å‘¨æœŸæ‰§è¡Œæ˜¯æ€ä¹ˆåšåˆ°çš„å‘¢ï¼Ÿ

åœ¨æˆ‘ä»¬è¿™é‡Œä¾‹å­ä¸­ï¼Œä»»åŠ¡æ˜¯ScheduledFutureTaskç±»å‹çš„ï¼Œæ‰€ä»¥æ‰§è¡Œä¼šè°ƒç”¨ScheduledFutureTaskçš„runæ–¹æ³•

```java
        public void run() {
            boolean periodic = isPeriodic();
            if (!canRunInCurrentRunState(periodic))
                cancel(false);
            else if (!periodic)
                ScheduledFutureTask.super.run();
            // ä¸»è¦æ˜¯è¿™é‡Œ
            else if (ScheduledFæ•´ä¸ªæµç¨‹å°±å·®ä¸å¤šæ˜¯è¿™æ ·ï¼Œä¸»è¦æ˜¯åˆ©ç”¨DelayedWorkQueueå’ŒScheduledFutureTaskæ¥å®ç°å»¶è¿Ÿæ‰§è¡Œå’Œå®šæ—¶ä»»åŠ¡çš„æ•ˆæœ

utureTask.super.runAndReset()) {
                setNextRunTime();
                reExecutePeriodic(outerTask);
            }
        }
```

runAndReset()æ‰§è¡Œä»»åŠ¡ï¼Œæ‰§è¡Œå®Œæ¯•åï¼ŒsetNextRunTimeè®¾ç½®ä¸‹ä¸€æ¬¡æ‰§è¡Œçš„æ—¶é—´ï¼Œç„¶åreExecutePeriodicå†æŠŠ

å½“å‰çš„ä»»åŠ¡å†åŠ å…¥åˆ°çº¿ç¨‹æ± ä¸­ã€‚è¿™æ ·å°±å®Œæˆäº†å‘¨æœŸæ‰§è¡Œã€‚

æ•´ä¸ªæµç¨‹å°±å·®ä¸å¤šæ˜¯è¿™æ ·ï¼Œä¸»è¦æ˜¯åˆ©ç”¨DelayedWorkQueueå’ŒScheduledFutureTaskã€‚é€šè¿‡DelayedWorkQueueæ¥å®è¡Œå»¶è¿Ÿæ“ä½œï¼Œåªæœ‰å»¶è¿Ÿåˆ°äº†ï¼Œä½ æ‰å¯ä»¥è·å¾—é˜Ÿåˆ—é‡Œé¢çš„å€¼ã€‚è€ŒScheduledFutureTaskå®ç°å®šæ—¶ä»»åŠ¡çš„æ•ˆæœï¼Œå½“ä»»åŠ¡æ‰§è¡Œå®Œï¼Œä¼šæ›´æ–°ä¸‹æ¬¡æ‰§è¡Œçš„æ—¶é—´ï¼Œç„¶åå†æŠŠä»»åŠ¡æ”¾åˆ°çº¿ç¨‹æ± é‡Œé¢æ‰§è¡Œã€‚

å‚è€ƒï¼š[Javaå¹¶å‘ç¼–ç¨‹ï¼šçº¿ç¨‹æ± çš„ä½¿ç”¨](https://www.cnblogs.com/dolphin0520/p/3932921.html)

